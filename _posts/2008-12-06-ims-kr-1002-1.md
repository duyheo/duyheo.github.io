---
layout: standard
title: "문제 및 시험 상호운용성 정보 모델"
subtitle: "문제 및 시험 상호운용성"
categories: standard
---

<div class="book">
<table class="title_table">
<tbody>
<tr>
<td><a href="{{ "/assets/images/speclogo.jpg" | absolute_url }}" target="_blank"><img class="alignleft wp-image-204 size-full" src="{{ "/assets/images/speclogo.jpg" | absolute_url }}" alt="speclogo" width="144" height="302" /></a></td>
<td style="text-align: left;"><span style="font-size: 18pt;">IMS 평가 문항 상호운용성 -</span>
<span style="font-size: 18pt;"> 정보 모델</span></td>
</tr>
</tbody>
</table>
<table class="printhistory">
<tbody>
<tr>
<td>발행일</td>
<td>2008년 00월 00일</td>
</tr>
<tr>
<td>최신 버전</td>
<td>IMS 평가 문항 상호운용성 - 정보 모델 버전 2.1</td>
</tr>
<tr>
<td>이전 버전</td>
<td></td>
</tr>
</tbody>
</table>
<div class="legal">

<b>IPR 및 유포에 관한 공지사항</b>

이 표준을 활용하는 이는 표준을 적용하면서 인지하게 된 관련 특허 또는 지적재산권의 침해 가능성 사실을 코멘트와 함께 문서의 형태로 제공해야 한다.

IMS는 이 문서에 명시된 기술의 적용 또는 활용과 관련된 지적재산권 또는 기타 권리의 적용범위와 유효성에 대한 입장, 또는 그러한 권리와 관련하여 어느 정도까지 허용될 것인지에 대한 입장을 표명하지 않는다. 뿐만 아니라, 그러한 권리를 파악하는 노력을 기울였다는 사실 또한 명시하지 않는다. IMS 표준에 명시된 권리와 관련하여 IMS 절차에 관한 정보는 IMS 지적재산권 웹 페이지<sup>1)</sup>를 참조할 수 있다.
<p class="copyrightN">Copyright © IMS Global Learning Consortium 2007. All Rights Reserved.</p>
이 표준을 배포하거나 제품 또는 서비스 제공을 위해서 활용하고자 한다면, IMS Korea 표준화 포럼 사무국(한국교육학술정보원)에 승인 요청을 하고 이메일을 통해 승인을 받아야 한다.

IMS 정식회원 및 기부회원, 개발자 네트워크는 상기의 저작권 공지사항과 이 문장을 사본에 포함시키는 조건 하에 이 표준을 배포 및 활용할 수 있다. 그러나 저작권 공지사항 또는 IMS 명칭이 표기된 부분을 삭제하는 등, 이 표준을 훼손하는 행위는 금지된다. 단, IMS가 승인한 프로젝트그룹의 감독 하에 IMS 표준을 수정하는 경우는 예외적으로 허용된다.

상기 부여된 제한된 승인 내용은 영속적이며, IMS 또는 후임기관 그 누구라도 라이센스를 취소할 수 없다.

이 표준은 어떠한 보증도 하지 않으며, 특히 불침해에 대한 그 어떤 보증도 하지 않는다. 이 표준의 사용에 대한 책임은 온전히 사용자에 의하며, 그 어떤 컨소시엄이나 제공 주체도 이 표준을 사용함으로써 제3자가 직간접적으로 입을 수 있는 피해에 대해 책임지지 않는다.
<p class="copyrightB" style="text-align: center;"><b>Copyright © 2007 by IMS Global Learning Consortium, Inc.
</b>All Rights Reserved.</p>

</div>
<div class="annotation">

<hr />

<sup>1)</sup>IMS 지적재산권 웹 페이지 : <a href="http://www.imsglobal.org/ipr/imsipr_policyFinal.pdf">http://www.imsglobal.org/ipr/imsipr_policyFinal.pdf</a>

</div>
<table class="editor table text-center">
<tbody>
<tr>
<td colspan="4"></td>
</tr>
<tr>
<td class="ct" colspan="4">심의부회 :</td>
</tr>
<tr>
<td colspan="4"></td>
</tr>
<tr>
<td></td>
<td>성 명</td>
<td>근 무 처</td>
<td>직 위</td>
</tr>
<tr>
<td colspan="4"></td>
</tr>
<tr>
<td class="ct" colspan="4">원안작성 협력기관 : 한국교육학술정보원(IMS Korea 표준화 포럼)</td>
</tr>
<tr>
<td colspan="4"></td>
</tr>
<tr>
<td></td>
<td>성 명</td>
<td>근 무 처</td>
<td>직 위</td>
</tr>
<tr>
<td>(위 원 장)</td>
<td>황대준</td>
<td>
<div align="left">성균관대학교</div></td>
<td>교수</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>김성윤</td>
<td>
<div align="left">(주)포씨소프트</div></td>
<td>이사</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>김 현</td>
<td>
<div align="left">(주)씨티유니온</div></td>
<td>과장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>유욱종</td>
<td>
<div align="left">(주)다울소프트</div></td>
<td>부장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>조성현</td>
<td>
<div align="left">테크빌닷컴(주)</div></td>
<td>부사장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>조용상</td>
<td>
<div align="left">한국교육학술정보원</div></td>
<td>팀장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>장근원</td>
<td>
<div align="left">(주)크레듀</div></td>
<td>과장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>차남주</td>
<td>
<div align="left">(주)디유넷</div></td>
<td>부사장</td>
</tr>
<tr>
<td>(실무위원)</td>
<td>최성기</td>
<td>
<div align="left">SK C&amp;C</div></td>
<td>과장</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>권희춘</td>
<td>
<div align="left">수원여대</div></td>
<td>교수</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>김종현</td>
<td>
<div align="left">계원예술대학</div></td>
<td>교수</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>김현진</td>
<td>
<div align="left">한국교원대학교</div></td>
<td>교수</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>손진곤</td>
<td>
<div align="left">한국방송통신대학교</div></td>
<td>교수</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>정광식</td>
<td>
<div align="left">한국방송통신대학교</div></td>
<td>교수</td>
</tr>
<tr>
<td>(자문위원)</td>
<td>한태인</td>
<td>
<div align="left">(주)메디오피아</div></td>
<td>부사장</td>
</tr>
<tr>
<td>(간 사)</td>
<td>신성욱</td>
<td>
<div align="left">한국교육학술정보원</div></td>
<td>연구원</td>
</tr>
</tbody>
</table>

<hr />
<div class="row">
  {% include toc.html html=page.content sanitize=true id="my_toc" class="caption"%}
</div>
<div id="sec_overview" class="chapter">
<h2 class="chapter"><a name="intro">머 리 말</a></h2>
이 표준은 한국의 온라인 평가문항의 공유 및 유통 체제 확립을 위해 IMS Global Learning Consortium(이하 GLC)의 Question &amp; Test Interoperability 표준을 기초로 작성한 IMS Korea 단체표준이다. 이 표준은 한국의 문화적, 교육적, 언어적 특수성 등을 감안하여 현지화 등 확장을 고려하여 작성되었다. 또한 이 표준을 실제 구현할 때, 부분적으로 선택하여 적용할 수 있도록 필수와 선택 영역이 구분되어 있으므로 목적에 따라 선별적인 적용이 가능하다.

이 표준은 이러닝 분야 온라인 평가문항 및 시험 표현 방법을 체계적으로 바인딩할 수 있도록 정의된 모델로서, 평가시스템에서 응시자에게 문항 또는 시험을 전달하는 시점부터 응시, 피드백 제공, 결과 제출 단계까지의 프로세스를 생명주기 관점에서 표현할 수 있도록 설계되었다. 평가문항 및 시험은 IMS 콘텐츠 패키징 표준을 이용해서 구조화 될 수 있으며, IMS 콘텐츠 패키징 표준 포맷은 실제 유통되는 포맷으로서, 이러닝 플랫폼에 탑재(import) 또는 추출(export)되는 표준화된 메커니즘을 제공한다.

이 표준은 멀티파트로 구성되며, 다음과 같은 세가지 표준 문서로 구성된다.
<ul>
	<li>Part 1 : 정보모델 (Information Model)</li>
	<li>Part 2 : XML 바인딩(Binding)</li>
	<li>Part 3 : 활용 사례 및 실행 가이드(Best practice &amp; Implementation Guide)</li>
</ul>
이 표준은 저작권법에서 보호 대상이 되는 저작물이다. 이 표준 문서의 표지에 있는 지적재산권 공지 사항을 숙지할 것을 다시한번 강조한다.

참고로 이 표준은 현재 기술표준원의 표준개발협력기관 지원사업(2007년 ~2009년)의 일환으로 국가 표준(KS) (안) 개발에도 활용되고 있으며, 교육과학기술부의 사이버가정학습 및 디지털 교과서 등과 같은 정책사업에 우선 적용 가능한 표준이다. 뿐만 아니라, 온라인 테스트를 서비스하고 있는 고등교육기관 및 직업훈력기관에서도 적용 가능한 표준이다.

</div>
<!-- overview -->
<div id="chap_1" class="chapter">
<h2><a name="1">1 적용범위</a></h2>
이 표준은 평가에 사용된 개별 문항(items), 섹션(sections), 시험(tests) 전체에 대한 정보 모델에 대해 설명한다.

</div>
<!-- chap 1 -->
<div id="chap_2" class="chapter">
<h2><a name="2">2 인용 표준</a></h2>
<div id="sec_2.1" class="section">
<h3><a name="2.1">2.1 ISO/IEC, ITU</a></h3>
<ul>
	<li>ISO8601:2000 Data elements and interchange formats – Information interchange –</li>
	<li>Representation of dates and times</li>
	<li>ISO11404:1996 Information technology — Programming languages, their environments and</li>
	<li>system software interfaces — Language-independent datatypes</li>
	<li>ISO/IEC 9899:1999 Programming Languages - C</li>
</ul>
</div>
<div id="sec_2.2" class="section">
<h3><a name="2.2">2.2 참조 표준</a></h3>
<ul>
	<li>IEEE 1484.11.1, Standard for Learning Technology - Data Model for Content Object</li>
	<li>Communication</li>
	<li>RFC 2396 : Uniform Resource Identifiers (URI): Generic Syntax</li>
	<li>RFC 2045 : 2048 Multipurpose Internet Mail Extensions (MIME)</li>
	<li>RFC 3066 : Tags for the Identification of Languages <a href="http://www.ietf.org/rfc/rfc3066.txt">http://www.ietf.org/rfc/rfc3066.txt</a></li>
	<li>XHTML 1.1: The Extensible HyperText Markup Language XHTML Modularation
<a href="http://www.w3.org/MarkUp/modularization">http://www.w3.org/MarkUp/modularization</a></li>
	<li>XML Inclusions (XInclude) Version 1.0 : <a href="http://www.w3.org/TR/xinclude/">http://www.w3.org/TR/xinclude/</a></li>
	<li>Extensible Markup Language (XML), Version 1.0 (second edition)</li>
	<li>XML Schema Part 2: Datatypes <a href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a></li>
</ul>
</div>
</div>
<!-- chap 2 -->
<div id="chap_3" class="chapter">
<h2><a name="3">3 용어의 정의</a></h2>
<div id="sec_3.1" class="section">
<h3><a name="3.1">3.1 적응형 문항(Adaptive Item)</a></h3>
적응형 문항이란, 응시자가 문제풀기를 시도(attempt)할 때, 문항 자체의 표현(appearance) 또는 채점(응답 처리-response processing) 방식이 바뀌거나, 두 가지 방식 모두 적용되어 변형(adapt)되는 문항을 말한다. 예를 들어, 응시자는 처음에 문장 형태의 입력창(free-text entry)에 답안을 입력하는 형태로 문항 응시를 시작하지만, 해당 내용이 오답이거나 만족스럽지 못한 답안이면, 단순 선택형(simple choice)의 상호작용(interaction)을 대체하여 제시하고 이어지는 정답 확인에 대해서는 감점을 부여한다. 적응성(adaptivity)은 문항 저작자가 형성단계(formative situations)에서 사용할 문항을 생성할 수 있게 한다. 이 문항은 응시자가 주어진 과제를 풀어 가도록 도와주고, 이후 보다 나은 콘텐츠 순서를 결정할 수 있도록 그 과제를 풀어가는 과정(path)을 고려한 결과(outcome)를 제공한다.

</div>
<div id="sec_3.2" class="section">
<h3><a name="3.2">3.2 적응형 시험(Adaptive Test)</a></h3>
적응형 시험이란 이미 작성된 답안들을 기초로, 응시자에게 여러 다른 문항을 제시하는 시험이다. 이 표준은 사전조건과 분기(pre-conditions and branching)를 사용해 매우 제한된 수준의 적응성만을 지원한다.

참조 : 사전조건과 분기

</div>
<div id="sec_3.3" class="section">
<h3><a name="3.3">3.3 평가(Assessment)</a></h3>
평가란 응시자 자질의 한 부분을 측정하는 과정이다. 이 표준에서 평가는 시험(test)을 통해 실행되며, ’평가(assessment)’라는 용어는 평가 시험(assessment test)과 동일하게 취급된다.

</div>
<div id="sec_3.4" class="section">
<h3><a name="3.4">3.4 평가 시험(Assessment Test)</a></h3>
평가 시험이란 특정영역에 있는 응시자의 성과를 측정할 때, 결과값(예, 이해수준-level of mastery)을 결정하기 위해 사용되는 문항들의 구조화된 집합을 말한다. 평가 시험에는 문항의 순서 제어 (sequencing of items)와 결과값 계산을 가능하게 하기 위해 필요한 모든 지시사항이 포함된다 (예, 최종 시험 점수).

</div>
<div id="sec_3.5" class="section">
<h3><a name="3.5">3.5 평가 변수(Assessment Variable)</a></h3>
평가 변수란 문항 세션(item session) 또는 시험 세션(test session)과 관련된 값을 유지하기 위해 사용되는 변수를 말한다. 예를 들어, 응시자의 응답값(value of response), 또는 개별 문항(individual item)이나 전체 시험(entire test)의 결과값이 평가 변수 이다.

</div>
<div id="sec_3.6" class="section">
<h3><a name="3.6">3.6 평가 전송 시스템(Assessment Delivery System)</a></h3>
평가 전송 시스템이란 응시자를 위한 평가 관리 및 전송을 위한 시스템이다.

</div>
<div id="sec_3.7" class="section">
<h3><a name="3.7">3.7 시도(Attempt)</a></h3>
(한 문항에서의) 시도는 1회 이상의 응시자 세션(candidate sessions)에서 응시자가 문항과 상호작용한 과정(process) 자체를 말한다. 이러한 과정은 관련된 응답 변수(response variables)에 값을 할당하거나 갱신하는 것일 수 있다.

</div>
<div id="sec_3.8" class="section">
<h3><a name="3.8">3.8 저작 시스템(Authoring System)</a></h3>
저작 시스템이란 문항과 평가를 만들고 편집하기 위해 저작자가 사용하는 시스템을 말한다.

</div>
<div id="sec_3.9" class="section">
<h3><a name="3.9">3.9 기본 유형(Base-type)</a></h3>
기본 유형이란 사전 정의된 데이터 유형(data type)으로, 문항 변수(item variables)값을 추출하기 위한 단일 값 집합(a value set)을 정의한다. 이 표준이 설명하는 실행환경(runtime model)과 관련하여 이 변수들은 더 이상 세분화 혹은 나누어 질 수 없는 최하위 수준이다.

</div>
<div id="sec_3.10" class="section">
<h3><a name="3.10">3.10 기본 문항(Basic Item)</a></h3>
기본 문항이란 단 하나의 상호작용(interaction)만을 포함하는 문항이다.

</div>
<div id="sec_3.11" class="section">
<h3><a name="3.11">3.11 응시자(Candidate)</a></h3>
응시자란 답안을 작성함으로써 시험(test), 평가(assessment) 혹은 시험(exam)에 참여하는 사람을 말한다.

</div>
<div id="sec_3.12" class="section">
<h3><a name="3.12">3.12 응시자 세션(Candidate Session)</a></h3>
응시자 세션이란 응시자의 1회 시도(attempt)의 한 부분으로서 응시자가 문항과 상호작용(interaction)할 때 소요되는 시간이다. 1회 시도내에서 응시자 세션은 1회 이상 일어날 수 있다. 예를 들어, 응시자가 질문에 대한 답에 자신이 없어서, 동일 시험내의 두 번째 질문으로 이동했다가 다시 이전의 문제로 돌아가는 경우가 해당된다. 응시자가 첫 번 째 질문을 풀고 나면 해당 응시자 세션은 종료되지만, 해당 문제에 대한 시도(attempt)가 종료되진 않는다. 문제풀기 시도는 이후의 응시자 세션(subsequent candidate session)이 종료될 때까지 잠시 중지되며, 응답 처리(response processing)과 (해당할 경우)피드백(feedback)을 작동 시킨다.

</div>
<div id="sec_3.13" class="section">
<h3><a name="3.13">3.13 복제 엔진(Cloning Engine)</a></h3>
복제 엔진이란 하나의 문항 템플릿으로 다수의 유사 문항(복제 문항)을 만들기 위해 사용되는 시스템을 말한다.

</div>
<div id="sec_3.14" class="section">
<h3><a name="3.14">3.14 복합 문항(Composite Item)</a></h3>
복합 문항이란 하나 이상의 상호작용(interaction)을 포함하는 문항을 말한다.

</div>
<div id="sec_3.15" class="section">
<h3><a name="3.15">3.15 컨테이너(Container)</a></h3>
컨테이너란 기초적인 형태의 기본 유형(base-types) 값을 다수 포함할 수 있는 집합적인 데이터 유형을 말한다. 컨테이너는 비어있을 수도 있다.

</div>
<div id="sec_3.16" class="section">
<h3><a name="3.16">3.16 전송 엔진(Delivery Engine)</a></h3>
전송 엔진이란 문항(들)과 피드백(feedback) 및 성적 산출을 위한 응답에 대한 평가(evaluation)를 제출하고 전송하는 작업을 조율하는 과정을 말한다.

</div>
<div id="sec_3.17" class="section">
<h3><a name="3.17">3.17 피드백(Feedback)</a></h3>
피드백이란 하나의 결과 변수(outcome variable) 값을 기초로 응시자에게 조건에 따라 제시되는 모든 자료(material)을 말한다.

참조 : 통합 피드백(integrated feedback), 형식적 피드백(modal feedback), 시험 피드백(test feedback)

</div>
<div id="sec_3.18" class="section">
<h3><a name="3.18">3.18 상호작용(Interaction)</a></h3>
상호작용이란 응시자가 문항과 상호작용(interaction)을 주고 받을 수 있도록 해준다. 상호작용을 통해 응시자는 응답을 선택 또는 구성할 수 있다.

</div>
<div id="sec_3.19" class="section">
<h3><a name="3.19">3.19 통합 피드백(Integrated Feedback)</a></h3>
통합 피드백이란 문항의 본체인 itemBody 클래스에 통합된 피드백(feedback)에 부여된 명칭이다. 형식적 피드백(modal feedback)과는 다르게, 응시자는 통합적 피드백을 보면서 자신의 답변을 원하는 대로 변경할 수 있다.

</div>
<div id="sec_3.20" class="section">
<h3><a name="3.20">3.20 문항(Item)</a></h3>
문항이란 이 표준 내에서 상호 교환이 가능한 가장 작은 평가 객체(assessement object)이다. 문항은 '질문(question)' 그 이상이라 할 수 있는데, 그것은 문항이 다음의 세 가지, 즉 문항에 제시될 질문 및 지시사항, 응시자의 응답에 적용될 응답 처리(response processing) 및 제시될 수 있는(힌트와 해결을 포함한) 피드백을 포함하기 때문이다. 이 표준에서 문항은 assessmentItem 클래스로 표시되며 ‘평가 문항(assessment item)’이라는 용어는 문항(item)으로도 사용할 수 있다.

</div>
<div id="sec_3.21" class="section">
<h3><a name="3.21">3.21 문항 복제 (Item Clone)</a></h3>
문항 복제란 문항 템플릿에 의해 생성된 문항을 말한다.

</div>
<div id="sec_3.22" class="section">
<h3><a name="3.22">3.22 문항 구성요소(Item Fragment)</a></h3>
문항 구성요소란 문항을 구성하는 한 부분으로 그것을 포함하는 문항들과는 별개의 독립적으로 다루어진다.

참조 : 문항 세트(Item Set)

</div>
<div id="sec_3.23" class="section">
<h3><a name="3.23">3.23 문항 세션(Item Session)</a></h3>
문항 세션이란 특정 문항에서 한명의 응시자에 의해 이루어진 모든 시도(attempt)를 누적한 것이다.

</div>
<div id="sec_3.24" class="section">
<h3><a name="3.24">3.24 문항 집합(Item Set)</a></h3>
문항 집합이란 공통된 특징을 지닌 문항들의 집합을 말한다. 예를 들어, 집합내의 모든 문항들은 동일한 문항 구성요소(item fragment)에 의해 도입될 수 있는데, 이러한 경우 그 문항 구성요소는 종종 집합 리더(set leader)라고 불린다.

</div>
<div id="sec_3.25" class="section">
<h3><a name="3.25">3.25 문항 템플릿(Item Template)</a></h3>
문항 템플릿이란 다수의 유사 문항을 생성하기 위해 사용될 수 있는 템플릿을 말한다. 이렇게 생성된 문항을 복제 문항(clone items)이라고도 한다. 문항 템플릿은 특수 목적 복제엔진 (cloning engine)에 의해 문항 생성 작업에 사용될 수 있으며, 또는 전송 엔진(delivery engine)이 지원되는 경우, 문항 세션(item session)이 시작하는 시점에서 동적으로 선택된 복제 문항의 생성에도 직접 사용될 수 있다. 하나의 문항 템플릿에서 복제된 각 문항은 템플릿 변수(template variables) 집합에 부여된 값만 제외하면 모두 동일하다. 하나의 문항은 결국 하나의 문항 템플릿이 되는 것이며, 이는 그 문항이 하나 이상의 템플릿 변수를 선언하고, 이들에게 값을 할당하기 위한 일련의 템플릿 처리(template processing) 규칙이 포함되어 있는 경우를 가정한다.

</div>
<div id="sec_3.26" class="section">
<h3><a name="3.26">3.26 문항 변수(Item Variable)</a></h3>
문항 세션(item session)의 상태를 기록하는 변수. 응시자의 응답들과, 응답 처리(response processing)를 거친 모든 결과가 응답 변수(response variable) 안에 저장된다. 문항 변수(item variable)들은 또한 문항 템플릿을 정의하기 위해 사용된다. 문항 변수는 평가 변수의 특수한 유형이라고 할 수 있다.

</div>
<div id="sec_3.27" class="section">
<h3><a name="3.27">3.27 자료(Material)</a></h3>
자료란 처리 시스템에 의해 해석되기 보다는 사용자를 위해 의도된 모든 고정된 텍스트(static text), 이미지, 미디어 객체를 의미한다. 상호작용(interaction)은 자료가 아니다.

</div>
<div id="sec_3.28" class="section">
<h3><a name="3.28">3.28 형식적 피드백(Modal Feedback)</a></h3>
형식적 피드백이란 응시자에게 독립적으로 제시되는 피드백(feedback)에 붙여진 명칭으로, 문항의 본체인 itemBody 클래스에 통합되는 것과는 반대되는 개념이다.

</div>
<div id="sec_3.29" class="section">
<h3><a name="3.29">3.29 다중 응답(Multiple Response)</a></h3>
다중 응답이란 응답 변수(response variable)로, 모두 기본 유형(base-types)들 중 하나에 의해 정의되는 값 집합에서 추출된 다중 값을 위한 컨테이너이다. 이 다중값은 이러한 값들의 정렬되지 않은 목록으로서 처리 된다. 이 목록은 비어있을 수 있다.

</div>
<div id="sec_3.30" class="section">
<h3><a name="3.30">3.30 비적응형 문항(Non-adaptive Item)</a></h3>
비적응형 문항이란 응시자의 시도(attempt)에 반응하지 않으며, 자체적으로도 변형(adapt)되지 않는 문항을 말한다.

</div>
<div id="sec_3.31" class="section">
<h3><a name="3.31">3.31 객체 은행(Object Bank)</a></h3>
객체 은행이란 문항(item), 문항 구성요소(item fragments), 시험(tests) 혹은 시험의 일부를 포함하는 평가(assessment)에 사용되는 객체의 집합이다. 객체 은행은 이 정보모형에서 직접적으로 표현하지는 않는다. 상호교환(interchange)을 위한 평가 객체를 패키징하는 방법은 IMS QTI 통합 가이드 문서(Integration Guide) 참조.

</div>
<div id="sec_3.32" class="section">
<h3><a name="3.32">3.32 순차 응답(Ordered Response)</a></h3>
순차 응답이란 응답 변수(response variable)로써, 기본 유형(Base-types)들 중 하나에 의해 정의 되는 값 집합에서 추출된 다중 값을 위한 컨테이너이다. 정렬된 응답은 값들의 정렬된 목록(순서)로서 처리된다. 이 목록은 비어있을 수 있다.

</div>
<div id="sec_3.33" class="section">
<h3><a name="3.33">3.33 결과(Outcome)</a></h3>
결과란 평가 시험(assessment test) 또는 문항(item)의 결과이다. 결과는 하나 또는 그 이상의 결과 변수(outcome variables)로 표현된다.

</div>
<div id="sec_3.34" class="section">
<h3><a name="3.34">3.34 결과 처리(Outcome Processing)</a></h3>
결과 처리란 문항 결과(item outcomes) (또는 응답)의 값이 모아져 시험 결과(test outcomes)를 만들어 내는 과정 자체를 말한다.

</div>
<div id="sec_3.35" class="section">
<h3><a name="3.35">3.35 결과 변수(Outcome Variable)</a></h3>
결과 변수는 결과 선언(outcome declarations)에 의해 정의된다. 이 값은 선언 자체에서 주어진 기본값으로부터 설정되거나, 또는 (문항 결과를 위한) 응답 처리(response processing) 또는 (시험 결과를 위한) 결과 처리(outcome processing) 과정에서 적용되는 응답 규칙(response rule)에 의해 설정된다.

참조 : outcomeDeclaration 클래스

</div>
<div id="sec_3.36" class="section">
<h3><a name="3.36">3.36 풀(Pool)</a></h3>
풀이란 그룹 전체를 설명하는 메타데이터와 함께 전송되는 관련 문항 그룹이다. 풀은 객체 은행(object bank)의 특수한 경우이다.

</div>
<div id="sec_3.37" class="section">
<h3><a name="3.37">3.37 응답(Response)</a></h3>
응답이란 문항 또는 문항의 일부와의 상호작용을 통해 응시자가 제공하는 데이터를 의미한다. 응시자의 응답 값은 응답 변수(response variables)로 표시된다.

</div>
<div id="sec_3.38" class="section">
<h3><a name="3.38">3.38 응답 처리(Response Processing)</a></h3>
응답 처리(response processing)란 응답 변수(response variables)값이 평가되고(채점되어) 문항 결과(item outcomes)의 값이 지정되는 과정을 말한다.

</div>
<div id="sec_3.39" class="section">
<h3><a name="3.39">3.39 응답 변수(Response Variable)</a></h3>
응답 변수란 응답 선언(resposne declarations)에 의해 선언되며, 문항 본체(item body) 내의 상호작용(interaction)에 바인딩되고, 응시자의 응답을 기록한다.

참조 : responseDeclaration 클래스

</div>
<div id="sec_3.40" class="section">
<h3><a name="3.40">3.40 채점 엔진(Scoring Engine)</a></h3>
채점 엔진이란 응시자의 응답과 응답 처리(response processing) 규칙을 기초로 채점을 진행하는 평가 스시템의 일부를 말한다.

</div>
<div id="sec_3.41" class="section">
<h3><a name="3.41">3.41 시험 피드백(Test Feedback)</a></h3>
시험 피드백이란 시험 결과값에 기초하여 조건적으로 응시자에게 제시되는 피드백을 말한다.

</div>
<div id="sec_3.42" class="section">
<h3><a name="3.42">3.42 단일 응답(Single Response)</a></h3>
단일 응답이란 기본 유형(Base-type) 중 하나에 의해 정의되는 값 집합에서 단일 값을 취할 수 있는 응답 변수(response variable)를 말한다.

</div>
<div id="sec_3.43" class="section">
<h3><a name="3.43">3.43 템플릿 처리(Template Processing)</a></h3>
템플릿 처리란 전형적으로 몇 개의 무작위 처리과정을 포함하여, 템플릿 변수 값을 설정하고, 그렇게 함으로서 문항 세션(item session)에 사용할 특정 복제를 선택하기 위해 사용되는 일련의 규칙들 (set of rules)을 말한다.

</div>
<div id="sec_3.44" class="section">
<h3><a name="3.44">3.44 템플릿 변수(Template Variable)</a></h3>
템플릿 선언으로 선언되며, 문항 템플릿을 초기화(instantiate)하는데 요구되는 값을 기록하는데 사용된다. 이 값들은 문항 템플릿에 의해 정의된 유사 문항 집합에서 어떤 문항이 복제되어 문항 세션(item session)에 사용될 것인가를 결정한다.

</div>
<div id="sec_3.45" class="section">
<h3><a name="3.45">3.45 시험(Test)</a></h3>
참조 : 평가(assessment)

</div>
<div id="sec_3.46" class="section">
<h3><a name="3.46">3.46 시험 구성요소(Test Fragment)</a></h3>
시험을 구성하는 하위 요소로서, 독립적으로 관리된다.

</div>
<div id="sec_3.47" class="section">
<h3><a name="3.47">3.47 시험 보고(Test Report)</a></h3>
시험 보고는 시험 세션(test session)에 대한 보고(report) 이다.

</div>
<div id="sec_3.48" class="section">
<h3><a name="3.48">3.48 시험 세션(Test Session)</a></h3>
시험 세션이란 시험 및 시험이 포함하고 있는 문항과 응시자 간에 이루어 지는 상호작용을 말한다.

</div>
<div id="sec_3.49" class="section">
<h3><a name="3.49">3.49 시간 제한 문항(Time Dependent Item)</a></h3>
시간 제한 문항이란 응답 처리(response processing)에서 사용되는 응답 변수(response variavle) 내에서 응시자 세션(candidate session)에 소요되는 시간의 누적을 기록하는 문항이다.

</div>
<div id="sec_3.50" class="section">
<h3><a name="3.50">3.50 시간 무제한 문항(Time Independent Item)</a></h3>
시간 무제한 문항이란 응답 처리(response processing)에서 소요 시간의 누적을 사용하지 않는 문항을 말한다. 실제로, 이 정보는 전송 엔진(delivery engine)에 의해 수집될 수 있으며, 시험 보고(test report)의 일부로 보고될 수도 있다.

</div>
</div>
<!-- chap 3 -->
<div id="chap_4" class="chapter">
<h2><a name="4">4 문항(Items)</a></h2>
이 표준에서 평가 문항이란 응시자에게 제시되는 정보와 그 문항을 채점하는 방법에 대한 정보를 포함한다. 응시자의 답안이 응답 처리 규칙에 의하여 결과로 변환되는 시점에 채점이 이루어 진다. 때로는 응시자에게는 동일한 것처럼 보이지만 실제로는 배점이 다른 문항을 여러 개 두는 것이 바람직할 때도 있다. 이 표준에서 이들 문항은 그 정의가 각기 다르며, 반드시 뚜렷한 식별자를 갖는다. 이러한 문항들의 표현(presentation)의 중요한 부분을 공유하는 문항 간 교환을 촉진하기 위해서, 이 표준은 itemBody 에서 개별적으로 관리되는 문항 구성요소(참조: 문항 및 시험 구성요소item and test fragment)를 지원한다.

<strong>클래스(Class) </strong>: assessmentItem

<strong>속성(Attribute)</strong> : identifier [1]: string

문항의 주 식별자. 이 식별자는 문항의 메타데이터 내에 해당하는 엔트리(entry)를 가져야 한다.

참조 : 메타데이터와 사용 데이터(metadata and usage data)

<strong>속성(Attribute)</strong> : title [1]: string

assessmentItem의 타이틀은 itemBody의 전체 텍스트를 이용할 수 없는 상황에서 문항이 선택될 수 있게 한다. 예를 들어, 응시자가 답안 작성을 어떠한 순서로 할 것인가를 결정하기 위해 문항을 검색하는 경우가 그것이다. 따라서 전송 엔진은 이 타이틀을 응시자에게 언제든 보여줄 수 있어야 하나, 의무사항은 아니다.

<strong>속성(Attribute)</strong> : label [0..1]: string256

<strong>속성(Attribute)</strong> : lang [0..1]: language

<strong>속성(Attribute)</strong> : adaptive [1]: boolean = false

문항은 적응형 문항과 비적응형 문항으로 나뉜다.

<strong>속성(Attribute)</strong> : timeDependent [1]: boolean

<strong>속성(Attribute)</strong> : toolName [0..1]: string256

toolName 속성은 문항을 작성하는 도구가 스스로를 확인(identify)하도록 한다. 다른 처리 시스템은 이 정보를 문항 itemBody의 요소에 대한 레이블과 같이 응용프로그램에 특화된 데이터의 내용을 해석하기 위해 사용할 수 있다.

<strong>속성(Attribute)</strong> : toolVersion [0..1]: string256

toolVersion 속성은 문항을 작성하는 도구가 자체 버전을 식별할 수 있도록 한다. 이 값은 반드시 toolName의 문맥에서만 해석되어야 한다.

<strong>포함(Contains)</strong> : responseDeclaration [*]

<strong>포함(Contains)</strong> : outcomeDeclaration [*]

<strong>포함(Contains)</strong> : templateDeclaration [*]

<strong>포함(Contains)</strong> : templateProcessing [0..1]

<strong>포함(Contains)</strong> : stylesheet [0..*]

<strong>포함(Contains)</strong> : itemBody [0..1]

<strong>포함(Contains)</strong> : responseProcessing [0..1]

<strong>포함(Contains)</strong> : modalFeedback [*]
<div id="sec_4.1" class="section">
<h3><a name="4.1">4.1 문항 세션 생애주기(Item Session LifeCycle)</a></h3>
문항 세션(item session)이란, 어떤 한 문항의 특정 인스턴스(particualr instance)에서 응시자에 의해 발생하는 모든 시도를 누적한 것이다. 어떠한 테스트 유형의 경우에는, 동일한 문항이 응시자에게 여러 번 제시되기도 한다. (예를 들어, 반복연습(drill and practice)) 문항에 이러한 상황이 발생하는 것이나 또는 문항의 인스턴스(instance)는 각각 자체의 문항 세션과 연계되어 있다.

다음의 도표는 문항 세션에 대한 사용자의 인지 상태를 보여준다. 모든 상태가 모든 시나리오에 적용되는 것은 아니다. 예를 들어, 어떤 문항에는 피드백이 제공되지 않을 수 있고, 또는 문항이 사용되는 문맥(context)에서 피드백이 허용되지 않을 수 있다. 마찬가지로, 응시자는 자신의 답안을 다시 검토할 수 없거나, 모델 솔루션을 살펴보지 못할 수 있다. 실제로는, 시스템은 제한된 횟수만큼 상태전환(state transition)의 표시를 지원하거나, 이 도표에서 보이지 않는 다른 상태전환을 지원할 수도 있다.

시스템 개발자가 시스템에 적용할 요구조건을 결정하기 위해 거쳐야 하는 첫 번째 중요한 단계는 그 시스템 내에서 지원되는 사용자 인지(user-perceived) 상태가 어떤 것인지 확인하고, 도표에서 표시된 상태전환을 본인의 이벤트 모델(event model)에 맞추는 것이다.

다음의 내용은 이 표준이 전송 엔진에 대해 제시하는 요구 조건 중 일부이다.
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_4.1.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-533 size-full" src="{{ "/assets/images/IMS-KR-1002-1_4.1.jpg" | absolute_url }}" alt="IMS KR 1002-1_4.1" width="515" height="541" /></a></div>
<p align="center">그림 4.1 문항 세션(item session)의 생애주기</p>
관련 문항이 먼저 응시자에게 전송하는데 있어 적합해 질 때 세션이 시작된다. 이 때 문항 세션(item session)의 상태는, 세션의 종료 시까지 응시자의 행위에 따라 갱신 및 유지 된다. 세션의 상태는 언제든 결과 보고 상태인 itemResult로 바뀔 수 있다. 전송시스템은 itemResult를 새로운 세션의 기초로 사용될 수 있도록 허용할 수 있는데, 이는 응시자의 답안이 문항 자체(그리고 아마도 솔루션과 비교해서) 콘텍스트에서 보여질 수 있게 하거나, 응시자가 중단했던 세션을 나중에 재개할 수 있도록 하는 것이 목적이다.

문항 세션(item session)의 초기 상태는 문항이 응시자에게 전달될 것이라는 결정은 내려졌으나 실제 전송(delivery)은 되지 않은 상태를 의미한다.

전형적인 비적응형 시험의 경우, 문항은 사전에 선택되며 응시자가 모든 문항과 진행하는 상호작용은 해당 응시자가 모든 문항을 시도했는가의 여부에 상관없이 시험 세션의 종료시점에 보고된다. 사실상, 문항 세션은 시험이 시작 될 때 모든 문항의 초기 상태에서 생성되며, 동일하게 유지된다. 반면 적응형 시험의 경우에는, 제시될 문항들이 해당 시점에 제시된 문항에 연계된 응답 및 결과에 기초하여, 세션 진행 중에 선택된다. 문항은 큰 풀(large pool)에서 선택되며, 전송 엔진은 실제로 선택된 문항과 응시자간의 상호작용을 보고만 한다.

응시자가 문항과 진행하는 상호작용은 0 또는 그 이상의 횟수로 나누어 진다. 각각의 시도마다, 응시자는 1회 또는 그 이상의 응시자 세션을 통해 문항과 상호작용한다. 응시자 세션 종료 시에, 문항은 다음의 응시자 세션을 준비하기 위한 중지 단계(suspended state)에 놓일 수 있다. 응시자 세션 중에는, 문항 세션(item session)이 상호작용 진행상태가 된다. 일단 시도가 종료되면, 응답 처리가 시작되고 응답 처리 이후에 새로운 시도를 할 수 있다

비적응형 문항의 경우, 응답 처리는 전형적으로 대개 1회로 끝나는 등 제한된 횟수로만 진행된다. 적응형 문항의 경우는 이러한 제한이 필요없는데, 그 이유는 응답 처리가 해당 문항을 통한 경로를 토대로, 자신이 지정한 값을 결과 변수에 적응(adapt)시키기 때문이다. 두 경우 모두, 각각의 시도가 종료될 때 응답 처리 시스템이 작동한다. 문항 본문의 외형, 그리고 형식적 피드백을 보여줄 것인가 하는 부분들은 결과 변수 값에 의해 결정된다.

더 이상의 시도가 허용되지 않을 때, 문항 세션이 종료상태로 넘어간다. 일단 이 상태로 진행되면, 응답 변수(response variable) 값이 확정된다. 문항이 종료상태로 넘어간 뒤에도, 전송시스템 또는 보고 도구(reporting tool)가 여전히 문항 제시를 허용할 수도 있다. 이러한 유형의 문항출력(presentation)은 검토단계 에서 발생하는데, 만약 응답 처리가 진행되고 적절한 결과 변수가 설정되었다면, 이 시점에서 요약 피드백(summary feedback)이 보여질 수도 있다.

마지막으로, 솔루션 화면을 보여주는 시스템의 경우, 문항 세션(item session)이 솔루션 상태로 넘어간다. 이 상태에서는, 응시자의 응답이 임시로 해당 responseDeclarations에서 제공된 올바른 값으로 대체된다. (만일 어떠한 것도 선언되지 않았을 경우 NULL 값)

<strong>클래스(Class) : itemSessionControl </strong>

관련 클래스(Associated Classes) :

testPart, sectionPart

문항이 시험의 일부로 참조될때, 시험의 시도 횟수와 허용되는 단계가 제한될 수 있다. 이러한 제한은 개별 문항에, 섹션 전체에, 또는 전체 testPart에 대해 기술되어 지정될 수 있다. 기본적으로, testPart 수준에서의 설정은, 해당 설정이 assessmentSection 수준 또는 최종적으로 개별assessmentItemRef 수준까지 덮어쓰기(override) 되지 않는 한, 해당 testPart에 속한 모든 문항에 영향을 미친다. 아래 제시된 초기값은 어떠한 적용 가능한 제한도 없는 경우에만 사용된다.

<strong>속성(Attribute)</strong> : maxAttempts [0..1]: integer

비적응형 문항의 경우, maxAttempts는 주어진 시험 맥락(context)이 허용하는 최대 시도 횟수를 제어한다. 비적응형 문항에 대한 채점 규칙이 각각의 시도에 동일하게 적용되므로, 일반적으로 이 속성 값은 1이다. 0값은 제한이 없음을 의미한다. 지정되지 않은 경우, 비적응형의 문항에서 maxAttempts는 1로 한다. 적응형 문항의 경우, maxAttempt 값은 무시되는데, 시도 횟수가 결과 변수에 내장(built-in)된 completionStatus 값에 의해 제한되기 때문이다.

1보다 큰 maxAttempts 값은, 정의상, 모든 적용가능한 피드백이 보여져야 한다는 것을 의미한다. 적용가능 할 경우, 이는 형식적 피드백 과 통합적 피드백 모두에 적용된다. 그러나, 허용된 시도 횟수가 모두 사용될 때 (혹은 적응형 문항의 경우에서 completionStatus가 완료(completed)로 설정되었을 때), 피드백을 보여줄지의 여부는 showFeedback 제약에 의해 제어된다

<strong>속성(Attribute) </strong>: showFeedback [0..1]: boolean

이 제약은 최종 시도가 종료된 후 피드백의 가시성에 영향을 준다. 만약 숨김(false) 값으로 설정된 경우, 피드백은 보여지지 않는다. 심지어 응시자가 검토단계에 대한 접근권을 가지고 있는 경우에도, 이 제한은 형식적인 피드백 과 통합적인 피드백 모두에 적용된다. 기본값은 숨김(false) 이다.

<strong>속성(Attribute) </strong>: allowReview [0..1]: boolean

이 제약은 최종 시도 종료 후의 피드백의 가시성에 영향을 미친다. 허용(true)으로 설정된 경우, 문항 세션은 검토단계로 들어가도록 허용되는데, 이 동안 응시자는 itemBody와 본인이 제시한 응답을 함께 검토할 수 있지만, 이를 업데이트하거나 응답을 다시 제출할 수는 없다. 불허(false)로 설정된 경우, 일단 마지막 시도의 응답을 제출했다면, 응시자는 itemBody 또는 그 응답을 다시 검토할 수 없다. 기본값은 허용(true)이다.

만약 검토단계가 허용되고 피드백은 허용되지 않는 다면, 전송시스템은 검토과정의 일부로 진행된 마지막 시도에서 생성된 통합적 피드백이 보이지 않도록 각별한 주의를 기울여야 한다. 하지만, 피드백은 이전에 보이던 자료를 숨기는 형태를 취할 수 있으며, 뿐만 아니라 이전에 감추어져 있던 자료를 나타나게 하는 보다 일반적인 형태를 취할 수도 있다.

이러한 모호성을 해결하기 위해, 비적응형 문항의 경우, ‘피드백 없음’은 각각의 시도(attempt) 가 시작될 때마다 응시자에게 보여지는 itemBody의 버전으로 지정된다. 다시 말해, 모든 통합적 피드백의 가시성은 응답 처리의 실행으로 업데이트 된 결과 변수가 아니라 결과 변수의 기본값에 의해 결정된다는 것이다.

적응형 문항의 경우, 응답 처리의 반복적 특성으로 상황이 복잡해 질 수 있는데, 이 특성이 검토를위한 문항을 위치시키기 위한 적절한 상태를 확인하기 어렵게 만들기 때문이다. 전송 엔진에게 결과 변수 값의 임시저장(cache) 요청을 피하기 위해서는, allowReview가 허용(true)일 경우 적응형 문항을위해 showFeedback에 대한 설정은 무시되어야 한다. 검토단계에서는 통합적 피드백의 가시성을 결정하기 위해 결과 변수의 최종값이 사용되어야 한다.

<strong>속성(Attribute)</strong> : showSolution [0..1]: boolean

이 제약은 시스템이 응시자에게 솔루션단계로 들어가는 방법을 제공하는가의 여부를 제어한다. 기본값은 불허(false) 이다

<strong>속성(Attribute)</strong> : allowComment [0..1]: boolean

일부 전송시스템은 응시자 코멘트 캡쳐(comment capture)를 지원한다. 코멘트는 평가되는 응답이 아니며, 평가가 진행되는 동안, 응시자로부터의 피드백을 다른 행위자에게 제공한다. 이 제약은 응시자가 세션 중에 문항에 대한 코멘트를 제공하도록 허용할 것인가의 여부를 제어한다.

<strong>속성(Attribute)</strong> : allowSkipping [0..1]: boolean = true

응시자가 응답을 제공하지 않았을 경우, 문항을 건너띄도록 지정한다. 다른 말로, 모든 응답 변수(response variable)들이 기본값과 같이 제출되거나, 또는 NULL 이 된다. 이와 같은 정의는 outcomeProcessing 안에서 사용가능한 numberResponded 연산자(operator)와 일치한다. 불허(false) 인 경우, 응시자는 문항을 건너띌 수 없다. 또는 다른 말로, 응답 변수(response variable) 중 적어도 하나에 대한 비기본값을 제공할 때까지 응시자에게 문항 제출이 허용되지 않는다. 정의상, 응답 변수(response variable)를 갖지 않는 문항은 건너띌 수 없다. 이 속성값은 문항이 개별 제출모드(submission mode)를 가진 testPart 안에 있을 때에만 적용할 수 있다. allowSkipping이 허용(true)인 경우, 전송 엔진은 응시자가 응답 없음을 선택할 수 있도록 해야 한다. "건너띄기(skip)" 버튼을 제공하는 것이 예가 될 수 있다.

<strong>속성(Attribute)</strong> : validateResponses [0..1]: boolean

이 속성은 응시자가 무효 응답(invalid response)을 제출했을 경우 전송 엔진의 행동을 제어한다. 무효 응답이란, 연계된 interaction이 걸어 둔 제약을 만족하지 않는 응답을 말한다. 상세정보는 interaction 참조. validateResponses가 작동되면(true), 응시자는 모든 interaction에 유효 응답을 제공할 때까지 문항을 제출할 수 없다. 작동 해지(false)인 경우, 무효 응답은 시스템에 의해 수용될 수 있다. 이 속성값은 문항이 개별 제출모드를 가진 testPart 안에 있을 때에만 적용할 수 있다. (참조 : 문항 검색(navigation)과 제출)

</div>
</div>
<!-- chap 4 -->
<div id="chap_5" class="chapter">
<h2><a name="5">5 문항 변수(Item Variable)</a></h2>
<strong>추상(Abstract) </strong><strong>클래스</strong>: variableDeclaration

<strong>파생된(Derived) </strong><strong>클래스</strong>: outcomeDeclaration, responseDeclaration, templateDeclaration
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_5.1.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-534 size-full" src="{{ "/assets/images/IMS-KR-1002-1_5.1.jpg" | absolute_url }}" alt="IMS KR 1002-1_5.1" width="480" height="482" /></a></div>
<p align="center">그림 5.1 변수 선언</p>
문항 변수(item variable)는 변수 선언에 의해 선언된다. 모든 변수들은 반드시 선언되어야 하지만, 단 아래에 언급된 내장(built-in)세션의 경우는 제외한다. 이들은 암시적으로 선언된다. 이 선언의 목적은 식별자와 변수를 연결하고, 변수값의 런타임(runtime) 유형을 식별하는 것이다.

문항 변수(item variable)는 값을 전혀 갖지 않을 수 있는데, 이 경우를 특수값 NULL 이라고 한다. 예를 들어, 응시자가 어떤 상호작용에 반응할 기회를 갖지 못했다면, 이때 모든 관련 응답 변수(response variable)는 NULL 값을 갖게 된다. 빈 컨테이너와 빈 문자열은 항상 NULL 값으로 취급한다.

<strong>속성(Attribute)</strong> : identifier [1]: identifier

내장(built-in) 세션변수의 식별자는 보류되어 있으며, 이러한 것들에는 completionStatus, numAttempts, duration 등이 있다. 한 문항에서 선언된 모든 문항 변수(item variable)들은 동일한 네임 스페이스를 갖는다. 서로 다른 문항들은 각기 다른 네임스페이스를 갖는다.

<strong>속성(Attribute)</strong> : cardinality [1]: cardinality

각 변수는 단일 값이거나 또는 다중 값이다. 다중 값 변수는 컨테이너로 불리며, 순차적(ordered), 비순차적(unordered), 레코드(record) 형태로 정의된다. 참조 : cardinality

<strong>속성(Attribute)</strong> : baseType [0..1]: baseType

변수 값이 도출되는(컨테이너의 경우 개별 값이 도출되는) 값 영역(value space)은 baseType으로 식별된다. 런타임 데이터 모델 내에서 baseType은 아토믹(atomic)값을 갖는 것으로 간주되는 사전 정의된 유형의 작은 집합 중 하나를 선택한다. 레코드 다중성(record cardinality)을 갖는 변수는 기본 유형(base-type)을 갖지 않는다.

<strong>포함(Contains) </strong>: defaultValue [0..1]

변수에 대한 선택적(optional) 기본값. 변수가 기본값으로 설정되는 시점은 문항 변수(item variable)의 유형에 따라 달라진다.

<strong>클래스(Class)</strong> : value

<strong>관련 </strong><strong>클래스(Associated Classes) : </strong>

ordinaryStatistic, templateVariable, candidateResponse, correctResponse, outcomeVariable, defaultValue

변수 선언과 결과 보고 내에서 어떠한 baseType의 단일 값(single value) 이라도 표현할 수 있는 클래스이다. 기본 유형(base-type)은 이 선언의 baseType 속성에 의해 정의되는데, 레코드 다중성 (record cardinality)을 갖는 변수의 경우는 예외이다.

<strong>속성(Attribute) </strong>: fieldIdentifier [0..1]: identifier

레코드의 일부를 형성하는 값의 필드 식별자를 지정하기 위해서만 사용되는 속성.

<strong>속성(Attribute) </strong>: baseType [0..1]: baseType

레코드의 일부를 형성하는 값의 기본 유형(base-type)을 지정하기 위해서만 사용되는 속성

<strong>클래스(Class)</strong> : defaultValue

<strong>관련 클래스(Associated Classes) : </strong>variableDeclaration

<strong>속성(Attribute)</strong> : interpretation [0..1]: string

기본 값을 사람이 읽을 수 있도록 해석한 것

<strong>포함(Contains) </strong>: value [1..*]

<strong>열거(Enumeration) </strong>: cardinality

single

multiple

ordered

record

표현식(expression) 또는 itemVariable은 단일(single) 값 이거나 다중(multiple) 값이 될 수 있다. 다중 값을 갖는 표현(또는 변수)을 컨테이너라고 부른다. 하나의 컨테이너는 값 목록을 포함하며, 이 목록이 NULL로 취급되는 경우 빈 것일 수 있다. 다중 또는 순차적 컨테이너(ordered container) 안의 모든 값은 동일한 세트 값에서 도출된 것이지만, 컨테이너에서는 동일한 값이 여러 번 나타날 수 있다. 다른 말로, [A,B,B,C] 가 한 컨테이너에서 수용 가능한 값이라고 하자. 다중 중복성(cardinality multiple) 과 값 [A,B,C] 를 갖는 컨테이너는, 값 [C,B,A]를 갖는 컨테이너와 유사한 셈이다. 하지만 이들 두 값은 순서화된 다중성(cardinality ordered)를 갖는 컨테이너와는 전혀 다른 것으로 간주된다. 응답 변수(response variable) 값으로 사용될 때, 이러한 구분은 다중응답 다중선택 작업에서의 답 선택하기와 객체 정렬 작업에서의 등수 선택하기 간의 차이점에 의해 전형적으로 보여진다. [ISO11404] 에 따르면, 다중 중복성(multiple cardinality)를 갖는 컨테이너는 "bag-type"으로, 순서화된 다중성(ordered cardinality)를 갖는 컨테이너는 "sequence-type", 레코드 다중성(record cardinality)을 갖는 컨테이너는 "record-type"으로 불린다.

레코드 컨테이너 유형은 독립된 값 세트를 갖는 일종의 특수 컨테이너다. 여기서 각각의 값은 자체 식별자로 구별되며 자체적인 기본 유형(base-type)을 갖는다. 이 표준은 레코드 유형을 직접적으로 사용하지는 않지만, customInteractions를 작동시켜, 보다 복잡한 응답을 조작하고, customOperators 를 작동시켜 보다 복잡한 값을 반환할 수 있게 한다.

<strong>열거(Enumeration) </strong>: baseType

기본 유형(base-type) 은 오토믹(atomic) 값 세트(이 표준에 대한 atomic)를 단순하게 설명한 것이다. 명심할 점은 런타임 데이터 모델을 정의하기 위해 사용되는 몇몇 baseType과, 표준 자체의 속성 값을 정의하기 위해 사용되는 기본 데이터 유형의 baseTypes 정의가 동일하다는 것이다. 런타임 모델에서 사용된 baseType 세트를 정의하기 위해 열거(enumeration)를 사용하는 것은, 유사한 이름을 갖는 클래스의 사용과는 대조적으로, 두 가지 별개 수준의 모델링의 구별을 돕기 위해 설계되었다.

identifier

식별자 값(identifier value) 집합은 identifier 클래스에 의해서 정의되는 값 집합과 동일하다

boolean

논리 값(Boolean value) 집합은 boolean 클래스에서 정의되는 값 집합과 동일하다

integer

정수 값(integer value) 집합은 integer 클래스에서 정의되는 값 집합과 동일하다

float

플로트 값(float value) 집합은 float 클래스에서 정의되는 값 세트와 동일하다

string

문자열 값(string value) 집합은 string 클래스에서 정의되는 값 세트와 동일하다

point

포인트 값(point value)은 그래픽 포인트에 상응하는 정수 튜플(integer tuple)을 나타낸다. 두 개의 정수는 각각 수평(X 축) 과 수직(Y축)을 나타내며. 축의 위/아래 와 좌/우는 문맥(context)에 따른다.

pair

쌍 값(pair value)은 두 객체 간 조합에 해당하는 식별자 한 쌍을 대표하는 값이다. 이 조합은 지시되지 않은(undirected) 것이므로, (A,B)와 (B,A)는 등가이다

directedPair

방향성 쌍(directedPair value)은 두 객체 간의 지시된 조합에 해당하는 식별자 한 쌍을 대표하는 값이다. 두 개의 식별자는 각각 그 소스와 대상 객체에 해당한다.

duration

실행시간(duration value)은 두 개의 시간 포인트 간 거리(시간 내에)를 지정한다. 다른 말로, [ISO8601]이 정의하는 시간대를 말한다. 실행시간은 초단위로 측정되며 소수부가 있을 수 있다.

file

파일 값(file value)은 콘텐츠 유형과 파일에 주어진 선택적(optional) 파일명에 의해 부여된 어떤 옥텟(8bit, 바이트)의 시퀀스(연속, sequence)를 뜻한다. (예를 들어, 응시자에 의해, 상호작용의 일환으로 파일을 업로딩 하는 경우). 파일의 콘텐츠 유형은 [RFC2045]에 의해 정의되는 MIME 유형 중의 하나이다.

<a id="element10064"></a>uri

URI 값은 [URI]에 의해 정의된 URI(Uniform Resource Identifier)이다.

<strong>클래스(Class) </strong>: mapping

<strong>관련 </strong><strong>클래스(Associated Classes)</strong> : responseDeclaration, categorizedStatistic

모든 baseType(파일과 duration 제외) 소스 집합에서 단일 플로트(single float)로 매핑을 생성하기 위해 사용되는 특수 클래스. 명심할 점은 부동 소수점(floating point) 값을 매치시키는 작업이 어렵기 때문에 기본 유형 플로트(base-type float)부터 매핑하는 작업은 피해야 한다. (참조: 매치 연산자 (match operator)) 컨테이너를 매핑 할 때, 결과는 목표 집합에 있는 매핑한 값의 합이 된다. (참조 : <a href="#element10578">mapResponse</a>)

<strong>속성(Attribute)</strong> : lowerBound [0..1]: float

컨테이너를 매핑한 결과를 위한 하한(lower bound). 지정되지 않았다면, 하한이 없다는 뜻이다.

<strong>속성(Attribute)</strong> : upperBound [0..1]: float

컨테이너를 매핑한 결과에 대한 상한(upper bound). 지정되지 않았다면, 상한이 없다는 뜻이다.

<strong>속성(Attribute)</strong> : defaultValue [1]: float = 0

소스 값을 위한 구체적인 매핑이 명시적으로 주어지지 않았을 때 사용되도록 설정된 목표 집합에 있는 기본값

<strong>포함(Contains) </strong>: mapEntry [1..*]

맵은 mapEntries 집합으로 정의된다. 각 mapEntry 집합은 소스 집합의 개별 값을 단일 플로트(single float)로 매핑한다.

<strong>클래스(Class)</strong> : mapEntry

<strong>관련 </strong><strong>클래스(Associated Classes) </strong>: mapping

<strong>속성(Attribute)</strong> : mapKey [1]: valueType

소스 값

<strong>속성(Attribute)</strong> : mappedValue [1]: float

매핑된 값
<div id="sec_5.1" class="section">
<h3><a name="5.1">5.1 응답 변수(Response Variables)</a></h3>
<strong>클래스</strong><strong>(Class)</strong> : responseDeclaration (variableDeclaration)

<strong>관련</strong> <strong>클래스</strong><strong>(Associated Classes)</strong> : assessmentItem

응답 변수(response variable)는 응답 선언에 의해 선언되며 itemBody 안에서 상호작용을 하게 되어 있다.

런타임 시에, 응답 변수(response variable)는 문항 세션(item session)의 부분으로 시작된다. 이 응답 변수(response variable)의 값은 해당 초기값이 변수 선언에서 주어지는 가의 여부와 관계없이 항상 NULL로 초기화된다. NULL 값을 갖는 응답 변수(response variable)는 응시자가 응답을 제시하지 않은 상태임을 의미하며, 이는 응시자가 아직 문항 풀기를 전혀 시도하지 않았거나 응시자가 시도는 했지만 응답을 제공하지 않기로 결정했기 때문이다.

만약 응답 변수(response variable)에 기본값이 제공되었다면, 변수는 첫 번째 시도 시점에서 이 기본값으로 설정되게 된다. 만약 응시자가 문항을 전혀 시도하지 않는다면, 다른 말로 문항 세션(item session)이 초기단계에서부터 종료단계까지 상호작용 단계를 거치지 않은 채 그대로 통과해 버린 다면, 응답 변수(response variable)는 NULL로 남아있게 되며 기본값은 절대 사용되지 않는다.

전송 엔진 구현자는 기본 응답 변수(response variable) 값을 갖는 문항을 위한 사용자 인터페이스를 구현할 때 주의해야 한다. 만약 관련 상호작용이 기본단계에 남아 있는 경우 (즉, 기본값을 나타내는) 중요한 것은, 응시자가 이 값을 제출하고자 의도 했었고 제공된 기본값을 단순히 알아차리지 못한 것이 아니라는 점을 시스템이 확신하도록 해야 한다. 특히 응시자의 시도가 외부상황, 예를 들어 시간 초과 등을 이유로 종료된 경우에 적용된다. 이러한 사례를 구별하기 위해 필요한 기술은 사용자 인터페이스 디자인과 관련된 것으로써, 이 표준이 다루는 범위를 벗어난다.

<strong>포함(Contains)</strong> : correctResponse [0..1]

응답 선언은 선택적 correctResponse를 지정할 수 있다. 이 값은, 올바르거나 또는 맞는 값으로 간주되는 응답 변수(response variable)의 가능한 값 만을 의미한다. 정답/오답 이상의 보다 복잡한 차원으로 측정되는 응답의 경우에, 그 값은 해당(또는 어떤) 최적 값으로 설정 되어야 한다. 최종적으로 이러한 최적 값이 정의되지 않은 응답의 경우에 correctResponse는 반드시 생략되어야 한다. 만약 전송시스템이 어떤 솔루션 디스플레이를 지원한다면, 이 솔루션은 응시자에게 올바른 응답 값(지정된 곳에)을 보여주어야 한다. 올바른 값이 보여질 때, 그 값은 반드시 응시자가 제출한 응답과는 확실하게 구별되어 보여져야(필요한 경우 완전히 숨김으로 처리) 한다.

<strong>포함(Contains)</strong> : mapping [0..1]

응답 처리를 목적으로 하는 기본 값 집합으로부터 숫자 값 집합까지의 매핑을 제공한다. 매핑 사용법에 관한 정보는 mapResponse를 참조

<strong>포함(Contains)</strong> : areaMapping [0..1]

areaMapping은 baseType 포인트를 갖는 변수 선언에만 존재하는 것으로, 매핑의 대체 형식을 제공한다. 이 형식은, 단일 값(즉, 단일 포인트) 매핑 대신 좌표공간의 영역에 대해 테스트를 수행한다.

<strong>클래스(Class)</strong> : correctResponse

<strong>관련 </strong><strong>클래스(Associated Classes)</strong> : responseDeclaration, responseVariable

<strong>속성(Attribute)</strong> : interpretation [0..1]: string

정답 값을 사람이 읽을 수 있도록 해석한 것

<strong>포함(Contains)</strong> : value [1..*]

<strong>클래스(Class) </strong>: areaMapping

<strong>관련 </strong><strong>클래스(Associated Classes)</strong> : responseDeclaration

포인트 값의 소스 집합으로부터 플로트(float) 값의 목표 집합까지 매핑을 생성하기 위해 사용되는 특수 클래스. 컨테이너를 매핑할 때, 그 결과는 목표(target) 집합에 있는 매핑된 값의 총합이 된다. 상세정보는 mapResponsePoint 참조. 이 속성은 매핑에 관한 유사명칭을 가진 속성들과 동일한 의미를 갖는다.

<strong>속성(Attribute)</strong> : lowerBound [0..1]: float

<strong>속성(Attribute) </strong>: upperBound [0..1]: float

<strong>속성(Attribute)</strong> : defaultValue [1]: float = 0

<strong>포함(Contains) </strong>: areaMapEntry [1..*] {ordered}

맵은 areaMapEntry 집합으로 정의되며, 각 areaMapEntry는 좌표공간의 영역을 단일 플로트(single float)에 매핑한다. 포인트를 매핑 할 때, 각 영역은 순서대로 테스트를 거치며, 영역이 겹치고 포인트가 교점에 위치하는 경우 우선적으로 처리된다

<strong>클래스(Class)</strong> : areaMapEntry

<strong>관련 </strong><strong>클래스(Associated Classes)</strong> : areaMapping

<strong>속성(Attribute)</strong> : shape [1]: shape

영역의 형태(shape)

<strong>속성(Attribute)</strong> : coords [1]: coords

형태(shape)와 함께 해석되는 영역의 크기와 위치

<strong>속성(Attribute)</strong> : mappedValue [1]: float

매핑된 값
<div id="sec_5.1.1" class="section">
<h4><a name="5.1.1">5.1.1 내장형(built-in) 응답 변수</a></h4>
내장형(built-in) 응답 변수(response variable)는 numAttemps와 duration 두 가지이다. 암시적으로 선언되며 responseDeclaration 안에 나타날 수 없다.

모든 전송 엔진은 반드시 numAttempts 값을 유지해야 한다. 이것은 응시자에게 제시되는 각 문항에 대한 시도 횟수를 기록하는 단일 정수(single integer)이다. 값은 초기에는 0 이며, 시도를 시작 할 때 마다 1 만큼 증가한다.

시간 제한 문항(time dependent item)을 지원하는 시스템은 또한 duration의 값을 유지해야 한다. duration은 모든 시도(attempt)를 위한 모든 응시자 세션의 누적 시간(초 단위)을 기록하는 하나의 단일 플로트(single float)로서 정의된다. 즉, 문항 세션의 시작과 종료까지의 시간에서 세션이 중단 되었던 시간을 빼는 것이다. duration의 해석(resolution)은 반드시 적어도 1초이거나, 0.1초, 또는 미만이라야 한다. 만약 해석이 엡실론(epsilon)으로 표시되면, duration 각각의 값은 duration&lt;=t&lt; duration+epsilon의 범위 내에서 표현된다. 다시 말해, duration의 값은 절삭(truncated)된다.

시간 제약이 없는 문항의 duration 값은 어떠한 문항이나 시험-수준 표현((test-level expression)에서도 사용될 수 없다. 그럼에도 시스템은 그 값이 알려졌을 때 itemResults에 이를 반드시 보고해야 한다

</div>
</div>
<div id="sec_5.2" class="section">
<h3><a name="5.2">5.2 결과 변수(Outcome Variable)</a></h3>
<strong>클래스(Class)</strong> : outcomeDeclaration (variableDeclaration)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentTest, assessmentItem

결과 변수는 결과선언에 의해서 선언된다. 이들 값은 선언 자체에서 주어지는 기본값에서 정해지거나, responseProcessing 진행 중 responseRule에 의해 설정된다.

응시자의 문항에 대한 전반적인 성과를 표현하기데 있어 숫자형의 결과 변수를 선언하는 문항은 그 변수에 대한 결과이름을 "SCORE" 로 사용해야 한다.

런타임 시, 결과 변수는 문항 세션(item session)의 일부로 시작된다. 이 변수의 값은 기본값으로 초기화 되거나 responseProcessing 도중에 설정된다. 만약 선언에서 기본값이 주어지지 않았다면, 0으로 초기화되는 숫자 형(numeric type)의 결과가 아닐 경우 결과 변수는 NULL로 초기화된다.

비적응형 문항의 경우, 결과 변수 값은 responseProcessing이 작동하기 전에 기본값으로 재설정된다. 적응형 문항의 경우, 결과 변수는 이전 응답 처리 작동 과정에서 해당 변수에 할당된 값을 계속 유지한다. 참조 : 응답 처리(Response Processing)

<strong>속성(Attribute)</strong> : view [*]: view

결과 변수가 제공될 것으로 예상되는 응시자(intended audience)에게는 보기(view) 속성이 설정 될 수 있다. 보기(view) 속성이 지정되지 않았다면, 결과는 모두 보기(all view)로 처리된다. 복합 문항(complex item), 예를 들어 적응형 문항 또는 복합 템플릿 등은 응시자에게 유용하지 않은 결과를 선언할 수도 있지만, 문항 또는 시험 세션 과정에서 유용한 중간 값 또는 기타 정보를 얻기 위해 사용할 만한 결과가 선언될 수도 있다. 이러한 변수는 (문항 결과의 경우) 저작자 또는 (시험 결과의 경우) testConstructor의 보기(view)로 정의되어야 한다. 시스템은 적절하게 선언되었다면, 선언된 보기(view)를 기초로 결과 보고(result report)에서 결과(outcomes)를 제외시킬 수도 있다.

<strong>속성(Attribute) </strong>: interpretation [0..1]: string

변수 값을 사람이 읽을 수 있도록 해석하는 것

<strong>속성(Attribute)</strong>: longInterpretation [0..1]: uri

결과 변수 값에 대한 확장해석을 연결하는 선택적 링크(link)

숫자 유형을 갖도록 선언된 결과(outcomes)는, 특히 이 범위가 [0,1]과 다른 경우, normalMaximum 과 normalMinimum을 사용하여 가능한 값의 범위를 표시해야 한다.

<strong>속성(Attribute)</strong> : normalMaximum [0..1]: float

normalMaximum 속성은 숫자형 결과 변수의 최대 값을 선택적으로 정의하며, 반드시 양수의 값이어야한다. 속성이 주어진다면, 결과값은 normalMaximum으로 나눌 수 있고, 이후 [-1.0,1.0] 범위내의 정규화된 점수를 얻기 위해 (필요한 경우) 절삭될 수 있다. normalMaximum은 responseProcessing 또는 결과 변수 자체가 취할 수 있는 값에 영향을 주지 않는다.

<strong>속성(Attribute)</strong> : normalMinimum [0..1]: float

normalMinimum 속성은 숫자형 결과 변수의 최소값을 선택적으로 정의하며, 음수의 값을 가질 수 있다.

<strong>속성(Attribute)</strong> : masteryValue [0..1]: float

masteryValue 속성은 숫자형 결과 변수의 값을 선택적으로 정의하며, 이 값을 상회(above)할 경우 응시자는 측정(measured)하는 해당 영역(aspect)을 마스터(master) 된 것으로 간주한다.

<strong>포함(Contains)</strong> : lookupTable [0..1]

<strong>추상 </strong><strong>클래스(Abstract class)</strong> : lookupTable

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : interpolationTable, matchTable

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : outcomeDeclaration

outcomeDeclation과 연계된 추상 클래스로, 선언된 값 집합에 있는 숫자 소스 값부터 단일 결과 값까지의 색인(lookup) 테이블을 생성하기 위해 사용된다. 색인표는 소스 숫자 값이 결과 값으로 어떻게 변환되는 가를 정의하는 유사한 매핑 방식과 반대되는 방식으로 작동한다. 반면 (응답)매핑은 응답 값이 목표(target)숫자 값에 매핑되는 방법을 정의한다.

이러한 변환은 lookupOutcomeValue 규칙을 이용하여 responseProcessing 또는 outcomeProcessing 내에서 일어난다.

<strong>속성(Attribute)</strong> : defaultValue [0..1]: valueType

매칭하는 표 입력(entry)이 발견되지 않을 때 사용되는 기본 결과 값이다. 생략된다면, NULL 값이 사용된다.

<strong>클래스(Class) </strong>: matchTable (lookupTable)

matchTable은 소스에 정확하게 매칭되는 첫 번째 matchTableEntry를 찾음으로서 소스 정수(integer)를 변환한다.

<strong>포함(Contains) </strong> : matchTableEntry [1..*]

<strong>클래스(Class)</strong> : matchTableEntry

<strong>관련 </strong><strong>클래스(Associated classes)</strong>: matchTable

<strong>속성(Attribute)</strong> : sourceValue [1]: integer

정확하게 매치되어야 하는 소스 정수(integer)

<strong>속성(Attribute)</strong> : targetValue [1]: valueType

매치되는 것을 찾았을 때 결과를 설정하기 위해 사용되는 목표 값

<strong>클래스(Class)</strong> : interpolationTable (lookupTable)

interpolationTable 은 소스 플로트(또는 정수)를 변환하는데, 이는 그 소스 값보다 작거나 또는 (includeBoundary를 조건으로하여) 그와 동일한 sourceValue를 갖는 첫 번째 interpolationTableEntry를 찾음으로서 수행된다.

예를 들어, 보간법 표(interpolation table)을 사용하면 처리되지 않은 원 점수(raw score)를 등급을 표시하는 식별자에 매핑할 수 있다. 이 표는 또한 단순한 원점수를 눈금 척도의 값으로 변환하는 것과 같이 숫자 변환에도 사용될 수 있다.

<strong>포함(Contains) </strong> : interpolationTableEntry [1..*]

<strong>클래스(Class)</strong> : interpolationTableEntry

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: interpolationTable

<strong>속성(Attribute)</strong> : sourceValue [1]: float

이 엔트리에 매치되는 소스값에 대한 하한가(lower bound)

<strong>속성(Attribute)</strong> : includeBoundary [0..1]: boolean = true

sourceValue의 정확한 매칭이 이 엔트리에 일치 하는가의 여부를 결정한다. 참(true)인 경우, 기본값이 되며, 그 값의 정확한 매칭은 해당 엔트리의 매칭으로 간주된다.

<strong>속성(Attribute)</strong> : targetValue [1]: valueType

매칭을 발견했을 때 결과를 설정하기 위해 사용되는 목표값
<div id="sec_5.2.1" class="section">
<h4><a name="5.2.1">5.2.1 내장형(Built-in) 결과 변수</a></h4>
내장형(built-in) 결과 변수는 하나, completionStatus이다. 암시적으로 선언되며, outcomeDeclaration 내에서 나타날 수 없다.

전송 엔진은 일종의 단일 식별자(single identifier)인 내장형(built-in) 결과 변수 값 completionStatus 를 반드시 유지해야 한다. 이 변수는 지정된 값인 "not_attempted"로 시작한다. 첫 번째 시도에서, 이 값은 "알수없음(unknown)" 으로 변경된다. 이후에 responseProcessing 내의 setOutcomeValue 규칙에 의해 다른 값으로 설정되지 않는 한, 문항 세션(item session) 기간 동안 그 값으로 유지된다. 허용된 값은 모두 네 가지 이다. 'completed', 'incompleted', 'not_attempted', 'unknown'. 이들 값 중 어느 하나라도 응답 처리 과정 중에 설정될 수 있으며, 각 의미의 정의는 [CMI]를 참조한다. 만약, 적응형 문항(adaptive item)이 completionStatus를 'completed' 로 설정했다면, 해당 세션은 반드시 종료단계에 있어야 하지만, 문항 세션(item session)은 종료 전에 완료 신호를 기다릴 의무가 없으며, 문항 세션(item session)은 응시자의 직접적인 요청에 따라서나 시간초과 또는 여러 다른 예외적인 상황으로 인해 종료될 수 있다. 적응형 문항(adaptive Item)은 반드시 적절한 값을 유지해야 하며, completionStatus를 'completed' 로 설정하여 상호작용 주기, 응답 처리, 피드백을 멈추는 시점을 나타내야 한다. 비적응형 문항(non-adaptive item)은 completionStatus에 대한 값을 설정할 의무는 없으나 그렇게 할 수 있다. 전송 엔진은 [CMI]를 사용하여 소통할 때 completionStatus 값을 사용하도록 권장된다. 추가정보는 같이 제공되는 통합가이드 참조

</div>
</div>
</div>
<!-- chap 5 -->
<div id="chap_6" class="chapter">
<h2><a name="6">6 콘텐츠 모델 (Content Model)</a></h2>
<strong>클래스(Class) :</strong> itemBody (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentItem

<strong>포함(Contains) :</strong> block [*]

문항 본체(item body)는 문자, 그래픽, 미디어 객체, 상호작용과 같이 문항의 내용과 문항의 구성정보를 설명하는 것들을 담고 있다. 내용은 스타일시트 정보와 결합시켜 제시되며, 뚜렷하게 또는 암시적으로, 전송 또는 저작 시스템의 기본 스타일 규칙을 사용한다.

본체(body)는 관련 문항 세션(item session)이 상호작용 단계에 있을 때, 응시자에게 반드시 제시되어야 한다. 이 단계에서 응시자는 보여지는 각각의 interaction과 커뮤니케이션하여, 관련 응답 변수(response variable) 값을 설정 또는 업데이트 할 수 있어야 한다. 이 본체(body)는 응답 세션이 종료 또는 검토 단계에 있을 때 응시자에게 제시될 수 있다. 이들 단계에서 비록 응시자의 응답은 보여질 수 있더라도, interaction은 반드시 중지된 상태라야 하며 이는 응시자가 관련 응답 변수(response variable) 값을 설정 또는 업테이트하는 것을 방지하기 위해서 이다. 최종적으로, 본체(body)는 솔루션 단계에서 응시자에게 제시될 수 있는데, 이 경우는 응답 변수(response variable)의 올바른 값이 보여져야 하며 관련한 상호작용은 중단된다.

이 표준이 도입한 콘텐츠 모델은 [XHTML]에서 직접 도출된 개념들을 많이 사용하고 있다. 실제로, 표준의 이 부분이 XHTML 프로파일을 정의한다. XHTML에서 정의된 요소들 중 오직 일부만이 assessmentItem에서 허용되며, 이들 중 일부는 그 속성에 추가적인 제약이 주어진다. 이 표준 내에서 명확하게 정의된 XHTML로 정의된 이들 요소만 사용될 수 있다. 상세정보는 XHTML 요소 참조. 최종적으로, 이 표준은 몇 가지 새로운 요소를 정의하는데, 이는 interaction을 표현하기 위해, 그리고 통합적 피드백(integrated feedback)의 디스플레이와와 정의된 하나 또는 그 이상의 콘텐츠 보기(view)에 의해 제한되는 콘텐츠를 제어하기 위해 사용된다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>bodyElement

파생 클래스(Derived classes) :

atomicBlock, atomicInline, caption, choice, col, colgroup, div, dl, dlElement, hr, interaction, itemBody, li, object, ol, printedVariable, prompt, simpleBlock, simpleInline, table, tableCell, tbody, templateElement, tfoot, thead, tr, ul

문항 콘텐츠 모델 안의 모든 콘텐츠 객체가 갖는 루트 클래스는 bodyElement 이다. 이는 콘텐츠 모델의 모든 요소에 공통적으로 있는 속성의 갯수를 지정한다.

<strong>속성(Attribute) : </strong>id [0..1]: identifier

본체(body)를 구성하는 요소의 아이디(id)는 문항 내에서 반드시 유일한 것이어야 한다.

<strong>속성(Attribute) : </strong>class [*]: styleclass

클래스는 개별 본체(body) 요소에 할당될 수 있다. 다중 클래스 이름이 주어질 수 있다. 이들 클래스 이름은 해당 요소가 클래스 목록의 구성원임을 구별해준다. 클래스 구성원(membership)은, 저작시스템이 이 표준으로 차별화할 수 없는 콘텐츠 객체를 구별하기 위해 사용될 수 있다. 이 정보는 일반적으로 관련 스타일시트 내의 정의를 기초로 다른 포맷팅을 적용하기 위해 사용된다.

<strong>속성(Attribute) : </strong>lang [0..1]: language

요소의 주 언어를 말한다. 이 속성은 선택사항이며 대개의 경우 특정 구성요소를 둘러싸는 상위의 (enclosing) 요소로부터 상속받는다.

<strong>속성(Attribute) : </strong>label [0..1]: string256

레이블(label) 속성은 저작 시스템에게, 어플리케이션에 특화된 데이터를 갖는 콘텐츠 모델의 요소를 레이블링(labeling)하는 매커니즘을 제공한다. 만약 문항이 이 레이블을 사용한다면 관련 toolName 과 toolVersion속성을 위한 값 또한 반드시 제공되어야 한다.
<div id="sec_6.1" class="section">
<h3><a name="6.1">6.1 기본 클래스</a></h3>
콘텐트 모델의 기반을 이루는 것들은 본체(body) 요소를 (개별 그룹을 정의하는) 범주(category)들로 그룹화하기 위해 사용되는 여러 추상 클래스들이다.

<strong>추상 </strong><strong>클래스(Abstract class) : </strong>objectFlow

<strong>파생 클래스(Derived classes) : </strong>flow, param

<strong>관련 클래스(Associated classes) : </strong>object

객체(object) 내에 나타낼 수 있는 요소

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>inline

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : inlineInteraction, inlineStatic

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : simpleInline, dt, caption, atomicBlock

단락의 콘텐츠처럼 텍스트의 길이처럼 행동하는 요소

<strong>추상 </strong><strong>클래스</strong> :block

<strong>파생 </strong><strong>클래스(Derived classes) </strong>:blockInteraction, blockStatic, customInteraction, positionObjectStage

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : itemBody, simpleBlock

단락, 표 등 동일한 텍스트에 구조를 제공하는 요소. 대부분의 요소는 인라인(inline) 이거나 블럭(block) 이다.

<strong>추상 </strong><strong>클래스(Abstract class) : </strong>flow (objectFlow)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : blockInteraction, customInteraction, flowStatic, include, inlineInteraction

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : tableCell, div, dd, li

블럭 유형(block-type) 과 인라인 유형(inline-type) 요소를 포함하는 구성요소로 문항, 표 셀, 등에 나타날 수 있는 요소

<strong>속성(Attribute) : </strong>base [0..1]: uri

이 객체 범위에 대한 관련 URI 해석(resolving)을 위한 기반을 변경하기 위해 사용되는 선택적 URI. 관련 URI가 문항 구성요소(item fragment)의 일부로 포함된 경우, 각별한 주의가 필요하다. 추가정보는 문항 및 테스트 구성요소(item and test fragments) 참조

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>inlineStatic (inline)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :

atomicInline, gap, hottext, math, object, printedVariable, simpleInline, templateInline, textRun

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : hottext, prompt, templateInline

상호작용을 제외하는 인라인(inline) 하위 클래스

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>blockStatic (block)

<strong>파생 </strong><strong>클래스(Derived classes</strong>) :atomicBlock, div, dl, hr, math, ol, simpleBlock, table, templateBlock, ul

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : templateBlock, gapMatchInteraction, hottextInteraction

상호작용을 제외하는 블럭(block) 하위 클래스

<strong>추상 </strong><strong>클래스</strong> :flowStatic (flow)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :

atomicBlock, atomicInline, div, dl, hottext, hr, math, object, ol, printedVariable, simpleBlock, simpleInline, table, templateBlock, templateInline, textRun, ul

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :

simpleAssociableChoice, testFeedback, modalFeedback, simpleChoice

상호작용을 제외하는 플로우(flow) 하위 클래스

다음 클래스들은 XHTML이 사용하는 몇 가지 공통 요소 유형이다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>simpleInline (bodyElement, flowStatic, inlineStatic)

파생 클래스(Derived classes) :

a, abbr, acronym, b, big, cite, code, dfn, em, feedbackInline, i, kbd, q, samp, small, span, strong, sub, sup, tt, var

<strong>포함(Contains) :</strong> inline [*]

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>simpleBlock (blockStatic, bodyElement, flowStatic)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : blockquote, feedbackBlock, rubricBlock

<strong>포함(Contains) :</strong> block [*]

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>atomicInline (bodyElement, flowStatic, inlineStatic)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : br, img

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>atomicBlock (blockStatic, bodyElement, flowStatic)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : address, h1, h2, h3, h4, h5, h6, p, pre

<strong>포함(Contains) :</strong> inline [*]

<strong>클래스(Class) :</strong> textRun (flowStatic, inlineStatic, textOrVariable)

textRun은 글자들의 단순한 흐름이다. 콘텐츠 모델의 모든 다른 요소와는 달리, textRun은 bodyElement의 하위클래스가 아니다. textRun에 속성을 부여하기 위해서는 범위(span) 요소를 반드시 사용해야 한다.

</div>
<div id="sec_6.2" class="section">
<h3><a name="6.2">6.2 XHTML 요소</a></h3>
[XHTML]에서 도출된 콘텐츠 모델의 구조적 요소들은 [XHTML_MOD]에 제시된 분류에 따라 그룹지어져 문서화된다. 여기 목록화된 속성들만이 (부모 클래스에서 상속받은 속성들을 포함하여) 사용될 수 있다. 기본적으로 요소 및 속성들은 그에 해당하는 [XHTML]내부의 요소 및 속성과 동일한 해석 및 제약요건을 갖는다.
<div id="sec_6.2.1" class="section">
<h4><a name="6.2.1">6.2.1 텍스트 요소</a></h4>
<strong>클래스(Class) :</strong> abbr (simpleInline)

XHTML에 의해 정의된 타이틀 속성이 지원되지 않음에 유의.

<strong>클래스(Class) :</strong> acronym (simpleInline)

XHTML에 의해 정의된 타이틀 속성이 지원되지 않음에 유의.

<strong>클래스(Class) :</strong> address (atomicBlock)

<strong>클래스(Class) :</strong> blockquote (simpleBlock)

<strong>속성(Attribute) : </strong>cite [0..1]: uri

<strong>클래스(Class) :</strong> br (atomicInline)

<strong>클래스(Class) :</strong> cite (simpleInline)

<strong>클래스(Class) :</strong> code (simpleInline)

<strong>클래스(Class) :</strong> dfn (simpleInline)

<strong>클래스(Class) :</strong> div (blockStatic, bodyElement, flowStatic)

<strong>포함(Contains) :</strong> flow [*]

<strong>클래스(Class) :</strong> em (simpleInline)

<strong>클래스(Class) :</strong> h1 (atomicBlock)

<strong>클래스(Class) :</strong> h2 (atomicBlock)

<strong>클래스(Class) :</strong> h3 (atomicBlock)

<strong>클래스(Class) :</strong> h4 (atomicBlock)

<strong>클래스(Class) :</strong> h5 (atomicBlock)

<strong>클래스(Class) :</strong> h6 (atomicBlock)

<strong>클래스(Class) :</strong> kbd (simpleInline)

<strong>클래스(Class) :</strong> p (atomicBlock)

<strong>클래스(Class) :</strong> pre (atomicBlock)

비록 pre가 atomicBlock에서 상속되었지만, pre는 직접이든 간접이든 img, object, big, small, sub, sup와 같은 객체들을 포함하지 않는다.

<strong>클래스(Class) :</strong> q (simpleInline)

<strong>속성(Attribute) : </strong>cite [0..1]: uri

<strong>클래스(Class) :</strong> samp (simpleInline)

<strong>클래스(Class) :</strong> span (simpleInline)

<strong>클래스(Class) :</strong> strong (simpleInline)

<strong>클래스(Class) :</strong> var (simpleInline)

</div>
<div id="sec_6.2.2" class="section">
<h4><a name="6.2.2">6.2.2 목록 요소</a></h4>
<strong>클래스(Class) :</strong> dl (blockStatic, bodyElement, flowStatic)

<strong>포함(Contains) :</strong> dlElement [*]

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>dlElement (bodyElement)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :dd, dt

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : dl

<strong>클래스(Class) :</strong> dt (dlElement)

<strong>포함(Contains) :</strong> inline [*]

<strong>클래스(Class) :</strong> dd (dlElement)

<strong>포함(Contains) :</strong> flow [*]

<strong>클래스(Class) :</strong> ol (blockStatic, bodyElement, flowStatic)

<strong>포함(Contains) :</strong> li [*]

<strong>클래스(Class) :</strong> ul (blockStatic, bodyElement, flowStatic)

<strong>포함(Contains) :</strong> li [*]

<strong>클래스(Class) :</strong> li (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : ul, ol

<strong>포함(Contains) :</strong> flow [*]

</div>
<div id="sec_6.2.3" class="section">
<h4><a name="6.2.3">6.2.3 객체 요소</a></h4>
<strong>클래스(Class) :</strong> object (bodyElement, flowStatic, inlineStatic)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :positionObjectStage, graphicInteraction, positionObjectInteraction, mediaInteraction, drawingInteraction, gapImg

<strong>포함(Contains) :</strong> objectFlow [*]

<strong>속성(Attribute) : </strong>data [1]: string

data 속성은 객체와 관련된 데이터의 위치를 찾기 위한 URI 를 제공한다.

<strong>속성(Attribute) : </strong>type [1]: mimeType

<strong>속성(Attribute) : </strong>width [0..1]: length

<strong>속성(Attribute) : </strong>height [0..1]: length

<strong>클래스(Class) :</strong> param (objectFlow)

<strong>속성(Attribute) : </strong>name [1]: string

객체가 해석한 파라미터 이름

<strong>속성(Attribute) : </strong>value [1]: string

이름 붙여진 파라미터 객체로 넘어가기 위한 값. 이 값은 템플릿 변수 확장의 영향을 쉽게 받는다. 만약 변수가 "true"로 설정된 paramVariable과 함께 선언된 템플릿 변수의 이름인 경우, 템플릿 변수 값은 주어진 파라미터 값처럼 객체로 넘어간다.

파라미터 값처럼 템플릿 변수를 확장할 때, 식별자(identifier), 문자열(string), uri 이외의 유형들은 반드시 문자열로 변환되어야 한다. 숫자 유형은 적절한 경우 "%i" 또는 "%G" 형식을 사용하여 문자열로 변환된다. (숫자 데이터 포맷팅에 관한 논의는 printedVariable 참조). 기본형 논리(boolean) 값은 "true" 또는 "false" 중 하나의 문자열로 확장된다. 기본형 포인트(point) 값은 "%i" 포맷을 사용하여, 수평좌표, 수직좌표의 순서로 두 개의 공간분리 정수들까지 확대된다. 기본형 쌍(pair) 값과 방향 쌍(directedPair) 값은 두 개의 식별자로 구성된 문자열로 공간을 분리하여 전환된다. 기본형 실행시간(duration) 값은 "%G" 포맷을 사용하여 변환된다. 기본형 파일 값은 파라미터 확장에서 사용될 수 없다.

만약 값 유형(valuetype)이 REF 라면, 템플릿 변수는 반드시 기본형 <a href="#element10064">uri</a> 여야 한다.

<strong>속성(Attribute) : </strong>valuetype [1]: paramType = DATA

이 표준은 DATA와 REF의 사용을 지원하지만 OBJECT는 지원하지 않는다.

<strong>속성(Attribute) : </strong>type [0..1]: mimeType

값 유형(valuetype) REF 값 유형을 제공하기 위해 사용된다.

<strong>열거(Enumeration) </strong>: paramType

DATA

REF

</div>
<div id="sec_6.2.4" class="section">
<h4><a name="6.2.4">6.2.4 프리젠테이션 요소</a></h4>
<strong>클래스(Class) :</strong> b (simpleInline)

<strong>클래스(Class) :</strong> big (simpleInline)

<strong>클래스(Class) :</strong> hr (blockStatic, bodyElement, flowStatic)

<strong>클래스(Class) :</strong> i (simpleInline)

<strong>클래스(Class) :</strong> small (simpleInline)

<strong>클래스(Class) :</strong> sub (simpleInline)

<strong>클래스(Class) :</strong> sup (simpleInline)

<strong>클래스(Class) :</strong> tt (simpleInline)

</div>
<div id="sec_6.2.5" class="section">
<h4><a name="6.2.5">6.2.5 표 요소</a></h4>
<strong>클래스(Class) :</strong> caption (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : table

<strong>포함(Contains) :</strong> inline [*]

<strong>클래스(Class) :</strong> col (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : table, colgroup

<strong>속성(Attribute) : </strong>span [0..1]: integer = 1

<strong>클래스(Class) :</strong> colgroup (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : table

<strong>속성(Attribute) : </strong>span [0..1]: integer = 1

<strong>포함(Contains) :</strong> col [*]

<strong>클래스(Class) :</strong> table (blockStatic, bodyElement, flowStatic)

<strong>속성(Attribute) : </strong>summary [0..1]: string

<strong>포함(Contains) :</strong> caption [0..1]

<strong>포함(Contains) :</strong> col [*]

표가 직접적으로 col을 포함한다면, 표는 모든 colgroup 요소를 포함할 수 없다.

<strong>포함(Contains) :</strong> colgroup [*]

표가 colgroup을 포함한다면, 표는 모든 col 요소를 직접적으로 포함할 수 없다

<strong>포함(Contains) :</strong> thead [0..1]

<strong>포함(Contains) :</strong> tfoot [0..1]

<strong>포함(Contains) :</strong> tbody [1..*]

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>tableCell (bodyElement)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : td, th

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : tr

XHTML에서, 표 셀은 th 또는 td 중의 하나로 대표되며, 이들은 다음의 속성과 콘텐츠 모델을 공유한다:

<strong>속성(Attribute) : </strong>headers [*]: identifier

<strong>속성(Attribute) : </strong>scope [0..1]: tableCellScope

<strong>속성(Attribute) : </strong>abbr [0..1]: string

<strong>속성(Attribute) : </strong>axis [0..1]: string

<strong>속성(Attribute) : </strong>rowspan [0..1]: integer

<strong>속성(Attribute) : </strong>colspan [0..1]: integer

<strong>포함(Contains) :</strong> flow [*]

<strong>열거(Enumeration) </strong>: tableCellScope

row

col

rowgroup

colgroup

<strong>클래스(Class) :</strong> tbody (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :table

<strong>포함(Contains) :</strong> tr [1..*]

<strong>클래스(Class) :</strong> td (tableCell)

<strong>클래스(Class) :</strong> tfoot (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : table

<strong>포함(Contains) :</strong> tr [1..*]

<strong>클래스(Class) :</strong> th (tableCell)

<strong>클래스(Class) :</strong> thead (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : table

<strong>포함(Contains) :</strong> tr [1..*]

<strong>클래스(Class) :</strong> tr (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : thead, tbody, tfoot

<strong>포함(Contains) :</strong> tableCell [1..*]

</div>
<div id="sec_6.2.6" class="section">
<h4><a name="6.2.6">6.2.6 이미지 요소</a></h4>
<strong>클래스(Class) :</strong> img (atomicInline)

<strong>속성(Attribute) : </strong>src [1]: uri

<strong>속성(Attribute) : </strong>alt [1]: string256

<strong>속성(Attribute) : </strong>longdesc [0..1]: uri

<strong>속성(Attribute) : </strong>height [0..1]: length

<strong>속성(Attribute) : </strong>width [0..1]: length

</div>
<div id="sec_6.2.7" class="section">
<h4><a name="6.2.7">6.2.7 하이퍼텍스트 요소</a></h4>
<strong>클래스(Class) :</strong> a (simpleInline)

비록 a 가 simpleInline에서 인계되었지만, 직접이든 간접이든 또 다른 <a href="#element10239">a</a> 를 포함할 수 없다.

<strong>속성(Attribute) : </strong>href [1]: uri

<strong>속성(Attribute) : </strong>type [0..1]: mimeType

</div>
</div>
<div id="sec_6.3" class="section">
<h3><a name="6.3">6.3 MathML</a></h3>
[MathML]은 XML을 이용한 수리적 기법을 표시하는 마크업 언어를 정의한다. MathML의 주목적은 수학적 표현을 다른 문서, 특히 HTML 문서에 끼워넣기 위해 필요한 언어를 제공한다.

<strong>클래스(Class) :</strong> math (blockStatic, flowStatic, inlineStatic)

math class는 외적으로는 MathML 표준이 정의한다. math class는 문항의 콘텐츠 모델 안에서 인라인(inline), 블럭(block), 흐름(flow) 요소로서 기능할 수 있다.
<div id="sec_6.3.1" class="section">
<h4><a name="6.3.1">6.3.1 템플릿 변수와 MathML 조합하기</a></h4>
문항 템플릿을 생성할 때, 수학적 표현요소를 다양하게 변화시키는 것이 바람직한 경우가 많다. 비록, math 객체 안에 그 목적으로 정의된 printedVariable과 같은 객체를 끼워 넣는 것이 불가능하지만, 이 장에서 설명하는 기술을 사용하여 유사한 효과를 달성할 수 있다.

MathML에서 숫자는 표현(presentation or content representation)을 위해 &lt;mn&gt; 이나 &lt;cn&gt; 요소 중의 한 가지로만 표현된다. 마찬가지로, &lt;mi&gt;와 &lt;ci&gt;는 식별자를 다시 기술한다. 만약 mathVariable이 템플릿 변수의 선언에서 설정된다면, 템플릿 변수의 이름과 일치하는 &lt;mi&gt;와 &lt;ci&gt;의 모든 경우는 템플릿 변수값을 콘텐츠로 하여 반드시 &lt;mn&gt;과 &lt;cn&gt;으로 각각 교체되어야 한다.

템플릿 변수 확장 기술은 MathML의 다른 요소까지로 향후 확장될 가능성이 있다.

</div>
</div>
<div id="sec_6.4" class="section">
<h3><a name="6.4">6.4 변수 콘텐츠</a></h3>
이 표준은 assessmentItem 콘텐츠가 문항 세션(item session)의 단계에 따라 달라지게 만드는 두 가지 방법을 정의한다.

첫 번째 방법은 결과 변수 값을 기초로 한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>feedbackElement

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : feedbackBlock, feedbackInline

<strong>속성(Attribute) : </strong>outcomeIdentifier [1]: identifier

식별자 기본형을 갖고 있어야 하며 단일(single) 혹은 다중 중복성(multiple cardinality)이어야 하는 결과 변수의 식별자(identifier). feedbackElement의 가시성은 responseProcessing 중에 이 결과 변수에 값 (또는 값들)을 할당 함으로서 제어된다.

<strong>속성(Attribute) : </strong>showHide [1]: showHide = show

showHide 속성은 feedbackElement의 가시성이 어떻게 제어되는 가를 결정한다. 만약 보이기(show)로 설정되면, 피드백은 숨김(hide)이 기본값이 되고, 관련 결과 변수가 식별자 속성값과 일치하거나, 또는 이를 포함하는 경우에 보이기(show)가 된다. 만약 숨김(hide)으로 설정되면, 피드백은 보이기(show)가 기본값이 되고, 관련 결과 변수가 식별자 속성값과 일치하거나 또한 이를 포함하는 경우에 숨김(hide)이 된다.

<strong>속성(Attribute) : </strong>identifier [1]: identifier

showHide 속성과 함께 피드백 가시성을 결정하는 식별자.

비적응형(non-adaptive Item) 문항의 일부를 구성하는 피드백 요소는 직접 또는 간접적으로든 반드시 interaction 객체를 포함해서는 안된다.

interaction이 숨겨진 피드백 요소에 포함된 경우, 이 interaction 또한 숨겨져야 한다. 응시자는 관련 응답 변수(response variable) 값을 설정 또는 업데이트 할 수 없다.

<strong>열거(Enumeration) </strong>: showHide

show

hide

<strong>클래스(Class) :</strong> feedbackBlock (feedbackElement, simpleBlock)

<strong>클래스(Class) :</strong> feedbackInline (feedbackElement, simpleInline)

<strong>클래스(Class) :</strong> rubricBlock (simpleBlock)

관련 클래스(Associated classes) : assessmentSection

<strong>속성(Attribute) : </strong>view [1..*]: view

rubricBlock의 콘텐츠가 보여지게 될 view

rubricBlock은, 문항을 보고 있는 한명 이상의 행위자에게 지침을 표현하는 assessmentItem의 itemBody 일부를 식별한다. 비록, rubricBlock이 simpleBlocks으로 정의되지만, rubricBlock은 반드시 interaction을 포함해야 한다.

중첩된 bodyElement 또는 rubricBlock 의 가시성은 가장 바깥쪽에 있는 요소에 의해 결정된다. 달리 말하면, 만약 한 요소가 숨김으로 결정되면, 그 요소의 모든 콘텐츠가 조건적으로 가시성을 갖는 요소들을 포함해 숨김으로 처리되는데, 이 때문에 조건들이 만족되며. 그 반대의 경우 콘텐츠가 보이게 된다.

<strong>클래스(Class) :</strong> printedVariable (bodyElement, flowStatic, inlineStatic, textOrVariable)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

반드시 정의되었어야 하고, 단일 중복성(single cardinality)를 갖는 결과 변수 또는 템플릿 변수이다. 응답 변수(response variable) 값은 직접적으로 프린트 될 수 없는데, 이는 응시자가 의무적으로 실행하는 interaction을 통해 그 값이 응시자에게 암묵적으로 알려졌기 때문이다. 필요한 경우, 이 값들은 responseProcessing 중에 결과로 지정될 수 있으며, 응시자에게는 적절한 피드백 단계에서만 보여지는 bodyElement 일부로 화면에 나타날 수 있다.

만약 변수값이 NULL 인 경우, 요소는 무시된다.

다양한 baseType 문자열은 단순한 textRun으로 처리된다.

baseType 정수(integer) 또는 플로트(float) 변수는 아래 적힌 포맷팅 규칙을 사용해 textRun으로 처리된다. 플로트 값은 e, E, f, g, G, r, R 스타일로만 포맷되어야 한다.

baseType 실행시간(duration)의 변수는, 기간을 초 단위로 나타내며 플로트로 처리된다.

<strong>속성(Attribute) : </strong>format [0..1]: string256

숫자값을 문자열로 변환시킬 때 사용하는 포맷 변환 지정자. 상세설명은 숫자 포맷 규칙 참조

<strong>속성(Attribute) : </strong>base [0..1]: integer = 10

정수변수를 i 변환타입 코드를 갖는 문자열로 변환시킬 때 사용하는 숫자 베이스

baseType 파일(file) 변수는 사용자의 파일열기 컨트롤(대화상자)을 사용하여 변경된다. 이 컨트롤은 그 파일과 관련된 이름이 있는 경우 보여야 한다.

baseType uri 변수는 사용자가 식별된 소스 열기 컨트롤을 사용하여 변경된다. 예를 들어, URL 에서 하이퍼텍스트 링크 따라가기 등이다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>textOrVariable

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : printedVariable, textRun

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : gapText

예를 들어 inlineChoice 텍스트 등과 같이, 평문(plain text_만 허용되는 문맥(context) 내의 변수값 대체를 가능하게 하기 위해 사용되는 추상 클래스
<div id="sec_6.4.1" class="section">
<h4><a name="6.4.1">6.4.1 숫자 포맷 규칙</a></h4>
포맷 속성의 형식(syntax)은 포맷 변환 지정자를 기초로 하는데, 이는 printf 및 관련기능을 함께 사용하기 위해 C 프로그램 언어 [ISO_9899]에서 정의된 것이다.

각 변환지정자는 '%' 문자로 시작하며, 그 뒤를 이어서 0 이거나 보다 많은 flag 문자(#, 0, -, " " [space] and +), 최소의 필드 넓이를 표시하는 선택적 숫자열, 선택적 소수점 아래의 자리수(precision) (a 와 뒤를 잇는 0 또는 보다 많은 숫자로 구성됨), 마지막으로 변환타입 코드 E, e, f, G, g, r, R, i, o, X, x 중의 하나가 붙는다. 다만 예외는 i 와 r/R 인데, 여기서 i 는 C 표준에 따라 해석되며, 기본 속성을 사용하는 10 이외의 기본(base) 내에 있는 숫자들을 포맷하기 위해 사용될 수 있다. r/R은 g/G 와 동일한 방식으로 소수점 아래의 자리수에 의해 주어지는 중요한 수들의 숫자로 반올림되는데, 단 예외는 과학 형식(scientific format)이 사용될 수 있는 경우는 중요한 수들의 요청 숫자가 소수점 왼쪽의 숫자 보다 작을 때 뿐이다.

</div>
</div>
<div id="sec_6.5" class="section">
<h3><a name="6.5">6.5 스타일시트를 갖는 문항 포맷하기</a></h3>
<strong>클래스(Class) :</strong> stylesheet

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :assessmentItem

assessmentItem 를 갖는 외부 스타일시트를 연계하기 위해 사용된다.

<strong>속성(Attribute) : </strong>href [1]: uri

외부 스타일시트의 식별자 또는 위치

<strong>속성(Attribute) : </strong>type [1]: mimeType

외부 스타일시트 유형

<strong>속성(Attribute) : </strong>media [0..1]: string

스타일시트가 적용되는 미디어를 설명하는 선택적 미디어 기술자

<strong>속성(Attribute) : </strong>title [0..1]: string

스타일시트를 위한 선택적 타이틀

</div>
</div>
<!-- chap 6 -->
<div id="chap_7" class="chapter">
<h2><a name="7">7 상호작용(Interaction)</a></h2>
<strong>추상 </strong><strong>클래스(Abstract class) :</strong>interaction (bodyElement)
<p align="left"><strong>파생 </strong><strong>클래스(Derived classes)</strong> : blockInteraction, customInteraction, inlineInteraction, positionObjectInteraction</p>
interaction은 응시자가 문항과 상호작용하도록 해준다. interaction을 통해, 응시자는 응답을 선택 또는 작성할 수 있다. 응시자의 응답은 응답 변수(response variable) 안에 저장된다. 각 interaction은 적어도 하나의 응답 변수(response variable)와 연계되어 있다.

<strong>속성(Attribute) : </strong>responseIdentifier [1]: identifier

interaction과 연계된 응답 변수(response variable)

interaction의 상태는 관련 응답 변수(response variable) 값 설정을 위해 사용된다. 관련 응답 변수(response variable) 선언은 응답 변수(response variable)가 특정 baseType 과 다중성(cardinality)을 갖도록 만든다. 일부 interaction은 허용 가능한 응답 설정에 추가적인 제약을 두는데, 예를 들어 choiceInteraction 안에서 고를 수 있는 최소 또는 최대 선택 숫자를 제한하는 것이다. 어떤 상호작용적인 전송 엔진에서는, 응시자가 문항과 상호작용하는 동안 이들 제약을 확인하는 것이 가능하다. 응시자는 시험을 진행하면서 어떠한 문항이 유효응답을 갖고 있으며, 주의를 필요로 하는 가를 보여주는 일종의 지침을 볼 수 있거나, 또는 유효 응답이 선택/작성될 때까지 시험을 진행할 수 없을 지도 모른다. (시험 중 이러한 운영모드를 실행하는 방법에 관해서는 validateResponses 참조). 일부 경우, 전송 엔진은 유효 응답의 특정 유형을 제거하는 상호작용적인 제어를 제공하기도 한다. 예를 들어, 선택 횟수를 설정하여 interaction에 지정된 최대치를 초과하지 못하도록 제한하는 것이다.

응시자의 interaction 상태가 추가적인 제약을 만족시키지 못하는 상황이 벌어 질 수 있다는 점을 감안할 때, 문항 저작자는 응답 처리 규칙(제공되는 경우)이 유효하지 않은 응답 변수(response variable)가 확실하게 처리될 수 있도록 만들어야 한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>inlineInteraction (flow, inline, interaction)

<strong>파생 </strong><strong>클래스(Derived classes) </strong>: endAttemptInteraction, inlineChoiceInteraction, textEntryInteraction

인라인(inline)을 나타내는 상호작용

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>blockInteraction (block, flow, interaction)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : associateInteraction, choiceInteraction, drawingInteraction, extendedTextInteraction, gapMatchInteraction, graphicInteraction, hottextInteraction, matchInteraction, mediaInteraction, orderInteraction, sliderInteraction, uploadInteraction

콘텐츠 모델의 블럭(block) 처럼 행동하는 상호작용. 상호작용 대부분이 이 유형이다.

<strong>포함(Contains) :</strong> prompt [0..1]

상호작용을 위한 선택적 프롬프트

<strong>클래스(Class) :</strong> prompt (bodyElement)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : blockInteraction

<strong>포함(Contains) :</strong> inlineStatic [*]

프롬프트는 반드시 모든 중첩된 interaction을 포함해야 한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>choice (bodyElement)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : associableChoice, hotspotChoice, hottext, inlineChoice, simpleChoice

하나 이상의 사전 정의된 선택사항들을 선택하는 작업을 포함하는 많은 상호작용. 이들 선택사항은 모두 다음과 같은 공통된 속성을 지닌다.

<strong>속성(Attribute) : </strong>identifier [1]: identifier

선택사항 식별자. 이 식별자는 다른 선택사항 또는 문항 변수(item variable)에 의해 사용될 수 없다.

<strong>속성(Attribute) : </strong>fixed [0..1]: boolean = false

선택사항에서 fixed 속성이 참(true)이면 바로 상위에서 포함(enclosing)하고 있는 interaction이 선택의 셔플링(shuffling)을 지원한다 하더라도 interaction내에서 이 선택사항의 위치는 전송 엔진에 의해 절대 변경되어서는 안된다. 만약, 값이 정해지지 않은 경우에는 선택사항의 순서를 자유롭게 변동시킬 수 있다.

문항 템플릿(item template)에서, 선택사항의 가시성은 템플릿 처리과정에서 관련 템플릿 변수값의 설정을 통해서 제어될 수 있다. 문항 템플릿에 관한 추가내용은 문항 템플릿(item template) 참조

<strong>속성(Attribute) : </strong>templateIdentifier [0..1]: identifier

기본형 식별자(identifier)를 가져야 하며 반드시 단일(single) 또는 다중 중복성(multiple cardinality) 이라야만 하는 템플릿 변수 식별자. 연계 interaction이 문항 템플릿의 일부인 경우, 식별된 템플릿 변수 값은 선택사항의 가시성 제어를 위해 사용된다. 선택사항이 숨김 상태이면, 이는 선택될 수 없고, 그 내용 또한 다른 규정이 없는 한 응시자가 볼 수 없다.

<strong>속성(Attribute) : </strong>showHide [0..1]: showHide = show

showHide 속성은 선택사항의 가시성을 제어하는 방법을 결정한다. 보기(show) 로 설정되어 있으면, 선택사항은 기본값으로 숨김처리 되어 있다가, 관련 템플릿 변수가 선택사항 식별자와 일치, 또는 이를 포함하는 경우에만 보여지게 된다. 숨기기(hide) 로 설정된 경우, 선택사항은 기본값을 보이도록 했다가, 템플릿 변수가 선택사항 식별자와 일치, 또는 이를 포함하는 경우에만 숨김으로 처리된다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>associableChoice (choice)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : associableHotspot, gap, gapChoice, simpleAssociableChoice

사전 정의된 선택사항을 쌍(pair)으로 묶기를 포함하는 다른 여러 interaction에 관한 것이다. 이들 선택사항은 모두 다음의 공통된 속성을 지닌다:

<strong>속성(Attribute) : </strong>matchGroup [0..*]: identifier

해당 선택사항과 관련이 있는 선택사항 집합. 그 외의 다른 모든 선택은 제외된다. matchGroup이 주어지지 않았거나 또는 비어 있는 경우, 이 선택과 관련한 모든 다른 선택사항들은 자체의 매칭 제약에 영향을 반든다.
<div id="sec_7.1" class="section">
<h3><a name="7.1">7.1 단순 상호작용</a></h3>
<strong>클래스(Class) :</strong> choiceInteraction (blockInteraction)

choiceInteraction은 응시자에게 선택사항들을 제시한다. 응시자가 할 일은 하나 또는 이상의 선택 문항을 고르는 것이며, maxChoices의 최대치까지 선택할 수 있다. 이에 해당하는 최소 선택 숫자는 없다. 선택된 문항이 없으면 상호작용은 항상 초기화된다.

choiceInteraction 은 반드시 식별자 baseType과 단일(single) 혹은 다중 중복성(multiple cardinality) 을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 인 경우, 전송 엔진은 반드시 fixed 속성에 쉽게 영향을 받는 선택 문항의 순서를 무작위로 만들어야 한다.

<strong>속성(Attribute) : </strong>maxChoices [1]: integer = 1

응시자가 고를 수 있는 선택 문항의 최대 숫자. maxChoices 가 0인 경우, 제약이 없는 것이며, 1 (또는 0)보다 큰 경우, interaction은 반드시 다중 중복성(multiple cardinality)을 갖는 응답에 바인딩되어 있어야 한다..

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer = 0

유효 응답을 만들기 위해서 응시자가 반드시 선택해야 하는 선택 문항의 최소 숫자. maxChoices이 0인 경우, 응시자는 선택 문항을 선택할 의무가 없다. minChoice는 maxChoices가 설정한 제한 숫자보다 작거나 또는 같아야 한다.

<strong>포함(Contains) :</strong> simpleChoice [1..*]

사용자에게 보여지는 선택 문항의 순차적(ordered) 목록. shuffle이 참(true)으로 되어 있지 않는 한, 이 순서는 사용자에게 제시되는 순서 그대로이다.

<strong>클래스(Class) :</strong> orderInteraction (blockInteraction)

orderInteraction에서, 응시자가 할 일은 선택 문항을 기록하는 것이다. 선택 문항이 초기에 보여지는 순서는 중요하다. 기본적으로 응시자의 과제는 모든 선택 문항을 배열하는 것이지만, 선택 문항의 하위세트는 maxChoices와 minChoices 속성을 사용하여 요청할 수 있다. 지정된 경우, 응시자는 반드시 선택 문항의 하위세트를 선택하고 그에 대한 순서 배열을 지정하는 것이다.

orderInteraction 과 관련이 있는 응답 변수(response variable)에 대한 기본값이 지정되었다면, 그 값은 여기에 지정된 선택 문항의 순서를 덮어쓰기(override)하기 위해 사용되어야 한다.

본래 orderInteraction을 답안이 제시되지 않은 단계에서 변경하는 것이 어려울 수 있다. 특히 모든 선택사항이 순차적으로 되어 있는 기본적인 경우 어려울 수 있다. 실행자들은 응답 변수(response variables) 절에서 설명된 기본값 사용에 관한 이와 같은 문제에 대하여 명심해야 한다.

orderInteraction은 baseType 식별자와 순차적 다중성(ordered cardinality) 만을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>포함(Contains) :</strong> simpleChoice [1..*]

사용자에게 보여지는 선택 문항의 순차적 목록. shuffle이 참(true)이 아닌 한, 그 순서는 사용자에게 제시된 최초의 순서를 유지해야 한다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 인 경우, 전송 엔진은 반드시 최초에 제시되는 선택 문항의 순서를 무작위로 만들어야 하는데, 이들 선택 문항은 fixed 속성에 영향을 받기 쉽다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer

interaction에 대한 유효 응답을 만들기 위해서 응시자가 반드시 선택해서 배열해야 하는 선택 문항의 최소 숫자. 지정된 경우, minChoices는 반드시 1 또는 그 보다 커야 하지만, 주어진 선택 문항의 숫자를 초과할 수 없다. 미지정된 경우, 모든 선택 문항은 순차적으로 되어야 하고, maxChoices는 무시된다.

<strong>속성(Attribute) : </strong>maxChoices [0..1]: integer

interaction에 응답할 때, 응시자가 선택해서 명령하는 선택 문항의 최대 숫자. minChoices와 함께 사용되며, 지정된 경우, maxChoices는 minChoices와 같거나 그보다 커야 하며, 주어진 선택 문항의 숫자를 초과할 수 없다. 미지정된 경우, 모든 선택 문항은 순차적으로 정리될 수 있다.

<strong>속성(Attribute) : </strong>orientation [0..1]: orientation

orientation 속성은, 배열(ordering)이 고유의 수직적(vertical) 또는 수평적(horizontal) 해석을 갖는 표현(rendering) 시스템에 힌트를 제공한다.

<strong>클래스(Class) :</strong> simpleChoice (choice)

관련 클래스(Associated classes) :

orderInteraction, choiceInteraction

<strong>포함(Contains) :</strong>flowStatic [*]

simpleChoice는 flowStatic 객체를 포함하는 선택 문항으로, 하나의 simpleChoice는 중첩된 interaction을 하나라도 포함할 수 없다.

<strong>클래스(Class) :</strong> associateInteraction (blockInteraction)

associateInteraction은 blockInteraction로, 응시자에게 다수의 선택 문항을 제시하고 이들이 그 문항들 간에 associations를 생성하게 한다.

associateInteraction은 기본형 쌍(pair)과 단일(single) 혹은 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 인 경우, 전송 엔진은 선택 문항의 순서를 반드시 무작위로 만들어야 하는데, 이들 선택 문항은 fixed 속성에 영향을 받기 쉽다

<strong>속성(Attribute) : </strong>maxAssociations [1]: integer = 1

응시자가 만들 수 있는 association의 최대 숫자. maxAssociations이 0 이면, 제약이 없는 것이며, 1 (또는 0) 보다 크면, 그 interaction은 반드시 다중 중복성(multiple cardinality)을 갖는 응답에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>minAssociations [0..1]: integer = 0

유효 응답을 생성하기 위해서 응시자가 만들어야만 하는 association의 최소 숫자. 만약 minAssociations이 0 이면, 응시자는 association을 만들 의무가 없으며, minAssociations는 maxAssociations이 정해 놓은 한계보다 작거나 같아야만 한다.

<strong>포함(Contains) :</strong> simpleAssociableChoice [1..*]

선택 문항의 순차적 세트

<strong>클래스(Class) :</strong> matchInteraction (blockInteraction)

matchInteraction은 일종의 blockInteraction으로 응시자에게 선택 문항 두 세트를 제시하고, 동일한 세트의 선택 문항 쌍(pairs)이 아닌 이 두 세트 내의 선택 문항 쌍(pairs) 간에 association을 형성하게 한다. 선택 문항의 matchMax와 matchGroup 속성을 사용하여 허용 가능한 associations에 추가로 제약을 둘 수 있다.

matchInteraction는 기본형 방향 쌍(directedPair)과 단일(single) 혹은 다중 중복성(multiple cardinality)를 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 이면, 전송 엔진은 각각의 세트 내에서 제시되는 선택 문항의 순서를 반드시 무작위로 만들어야 하는데, 이들 선택 문항은 fixed 속성에 영향을 받기 쉽다

<strong>속성(Attribute) : </strong>maxAssociations [1]: integer = 1

응시자가 만들도록 허용된 association의 최대 숫자. 만약 maxAssociations가 0 이면, 아무 제한이 없는 것이다, maxAssociations이 1 (또는 0) 보다 크면, 그 interaction은 다중 중복성(multiple cardiniality)를 갖는 응답에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>minAssociations [0..1]: integer = 0

유효 응답을 생성하기 위해서 응시자가 만들어야만 하는 association의 최소 숫자. 만약 minAssociations이 0 이면, 응시자는 association을 만들 의무가 없으며, minAssociations는 maxAssociations이 정해 놓은 한계 보다 작거나 같아야만 한다.

<strong>포함(Contains) :</strong> simpleMatchSet [2]

선택 문항의 두 세트. 첫 번째 세트는 소스 선책 문항을 정의하며, 두 번째는 타겟을 정한다.

<strong>클래스(Class) :</strong> simpleAssociableChoice (associableChoice)

관련 클래스(Associated classes) :

associateInteraction, simpleMatchSet

<strong>속성(Attribute) : </strong>matchMax [1]: integer

이번 선택과 관련된 선택 문항의 최대 숫자. matchMax가 0 이면, 아무 제한이 없는 것이다.

<strong>속성(Attribute) : </strong>matchMin [0..1]: integer = 0

유효응답을 생성하기 위해 이번 선택과 관련이 있는 최소 선택 문항 수. 만약 matchMin이 0 이면, 응시자는 이 선택 문항을 다른 것과 연계시킬 의무가 전혀 없다. matchMin는 matchMax이 정해놓은 한계보다 작거나 같아야만 한다.

<strong>포함(Contains) :</strong> flowStatic [*]

associableChoice는 flowStatic 객체를 포함하는 선택 문항으로, 중첩된 상호작용을 포함해서는 안된다.

<strong>클래스(Class) :</strong> simpleMatchSet

관련 클래스(Associated classes) :

matchInteraction

<strong>포함(Contains) :</strong> simpleAssociableChoice [*]

세트를 위한 선택 문항의 순차적 세트

<strong>클래스(Class) :</strong> gapMatchInteraction (blockInteraction)

gapMatchInteraction은 응시자가 관련 선택 문항 세트에서 채울 수 있는 다수의 gap을 포함하는blockInteraction. 선택 문항에 표시된 응시자는 반드시 문맥(context)에서, 선택 문항에 표시된 바와 같이, 앞서 채운 gap을 갖는 콘텐츠를 검토할 수 있어야 한다.

gapMatchInteraction은 gap의 갯수에 따라 기본형 방향쌍(directedPair)과 단일(single) 또는 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다. 선택 문항은 쌍(pairing)의 소스를 나타내며 gap은 타겟의 소스를 나타낸다. 각 gap은 많아야 그 gap과 관련된 하나의 선택 문항만 가질 수 있다. 선택 문항의 최대 생성치는 gapChoice의 matchMax 속성에 의해 제어된다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 인 경우, 전송 엔진은 선택 문항의 순서(gap이 아니라) 를 반드시 무작위로 만들어야 하는데, 이들 선택 문항은 fixed 속성에 영향을 받기 쉽다

<strong>포함(Contains) :</strong> gapChoice [1..*]

gap을 채우기 위한 선택 문항의 순차적(ordered) 목록. 필요하다면, 선택 문항 숫자가 gap 숫자보다 적을 수 있다.

<strong>포함(Contains) :</strong> blockStatic [1..*]

상호작용 콘텐츠는 단순히 gap을 포함하는 콘텐츠의 한 부분이라고 할 수 있다. 블럭(block) 이 gap을 하나 이상 갖는 경우, interaction은 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>클래스(Class) :</strong> gap (associableChoice, inlineStatic)

gap은 gapMatchInteraction 내에만 나타나는 inlineStatic 요소이다.

<strong>속성(Attribute) : </strong>required [0..1]: boolean = false

참(true)로 설정된 경우, interaction에 유효 응답을 형성하기 위해서 이 gap은 반드시 응시자에 의해 채워져야 한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>gapChoice (associableChoice)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : gapImg, gapText

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: gapMatchInteraction

gapMatchInteraction에서 gap을 채우는 데 사용되는 선택 문항들은 단순한 textRun 또는 단순한 이미지 객체로, 둘 다 gapChoice 에서 파생된 것이다.

<strong>속성(Attribute) : </strong>matchMax [1]: integer

이번 선택과 관련된 선택 문항의 최대 숫자. matchMax 이 0 인 경우, 제약이 없다는 뜻이다.

<strong>속성(Attribute) : </strong>matchMin [0..1]: integer = 0

유효 응답을 형성하기 위해 이번 선택과 관련이 있어야 하는 gap의 최소 숫자. matchMax 이 0 인 경우, 응시자는 이 선택 문항을 다른 gap과 연계시킬 의무가 전혀 없다. matchMin은 matchMax가 지정한 한계치보다 적거나 동일해야 한다.

<strong>클래스(Class) :</strong> gapText (gapChoice)

사용자에 의해 gap에 삽입될 단순한 textRun은 printedVariable 를 갖는 다양한 변수 대체에 쉽게 영향을 받을 수 있다.

<strong>포함(Contains) :</strong> textOrVariable [*]

<strong>클래스(Class) :</strong> gapImg (gapChoice)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : graphicGapMatchInteraction

gap 이미지는 응시자에 의해 삽입될 단일 이미지를 포함한다.

<strong>속성(Attribute) : </strong>objectLabel [0..1]: string

삽입될 이미지 객체를 위한 선택적 레이블

<strong>포함(Contains) :</strong> object [1]

</div>
<div id="sec_7.2" class="section">
<h3><a name="7.2">7.2 텍스트 기반 상호작용(Text-based Interactions)</a></h3>
<strong>클래스(Class) :</strong> inlineChoiceInteraction (inlineInteraction)

inlineChoice는 사용자에게 단순한 텍스트 일부라고 할 수 있는 선택 문항 세트를 제시하는 inlineInteraction이다. 응시자가 할 일은 이 선택 문항 중의 하나를 고르는 것이다. choiceInteraction 과는 다르게, 전송 엔진은 응시자로 하여금 주변 텍스트의 문맥(context) 내에서 그들의 선택 문항을 검토할 수 있도록 해야 한다.

inlineChoiceInteraction은 baseType 식별자(identifier) 와 단일 중복성(single cardinality) 만을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>포함(Contains) :</strong> inlineChoice [1..*]

사용자에게 보여지는 선택 문항의 순차적 목록. shuffle 이 참(true)이 아닌 한, 이 순서는 사용자에게 제시되는 순서가 된다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

shuffle 속성이 참(true) 인 경우, 전송 엔진은 선택 문항의 순서를 반드시 무작위로 만들어야 하는데, 이들 선택 문항은 fixed 속성에 영향을 받기 쉽다

<strong>속성(Attribute) : </strong>required [0..1]: boolean = false

참(true) 인 경우, 이 interaction에 대한 유효응답을 형성하기 위해 선택 문항은 반드시 응시자에 의해 선택되어야 한다.

<strong>클래스(Class) :</strong> inlineChoice (choice)

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: inlineChoiceInteraction

사용자에게 제시될 단순한 textRun은 printedVariable을 갖는 다양한 변수대체에 쉽게 영향을 받을 수 있다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>stringInteraction

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : extendedTextInteraction, textEntryInteraction

문자열 interaction은, 바람직한 경우 문자열 대신 숫자 응답 변수(response variable)에 바인딩될 수 있다.

숫자 응답에 관한 상세정보가 필요하다면, 문자열 interaction은 레코드 다중성(record cardinality)을 갖는 응답 변수(response variable)에 바인딩될 수 있다. 결과값은 다음과 같은 필드를 포함한다.

stringValue: 문자열, 응시자가 작성한 대로

floatValue: 응시자가 작성한 문자열 숫자값, float처럼

integerVariable: 분수 숫자 또는 지수가 지정되지 않았거나, 그렇지 않으면 NULL 이었을 경우, 응시자가 작성한 문자열의 숫자값. 일종의 integer

leftDigits: 소수점 왼쪽에 있는 숫자. 일종의 integer

rightDigitis: 소수점 오른쪽에 있는 숫자. 일종의 integer

ndp: 응시자가 지정한 분수 숫자. 지수가 주어지지 않았다면, 이는 rightDigits 과 동일함. 일종의 integer

nsf: 응시자가 지정한 중요한 숫자. 일종의 integer

exponent: 응시자가 제공한 integer 지수, 아무것도 지정되지 않았다면 NULL

<strong>속성(Attribute) : </strong>base [0..1]: integer = 10

문자열 interaction이 숫자형 응답 변수(response variable)에 바인딩되어 있다면, 기본 속성은 응시자가 입력한 값을 해석하기 위한 숫자 기반(base)을 설정하기 위해 반드시 사용되어야 한다.

<strong>속성(Attribute) : </strong>stringIdentifier [0..1]: identifier

문자열 interaction이 숫자형 응답 변수(response variable)에 바인딩되어 있다면, 응시자가 입력한 실제 문자열은 또한 interaction을 두번째(second) 응답 변수(response variable)(기본형 string의)에 바인딩함으로써 캡쳐될 수 있다.

<strong>속성(Attribute) : </strong>expectedLength [0..1]: integer

expectedLength 속성은 기대되는 응답의 전반적인 예상 길이에 대한 힌트를 응시자에게 제공한다. 전송 엔진(delivery Engine)은 적용 가능한 경우 이 속성값을 사용하여 응답 박스의 크기를 설정해야 한다. 이는 유효성 제약은 아니다.

<strong>속성(Attribute) : </strong>patternMask [0..1]: string

이것이 주어진다면, patternMask는 응시자의 응답이 유효하기 위해서 반드시 일치시켜야 하는 정규식(regular expression)을 구체적으로 정한다. 여기서 사용된 정규식 언어는 첨부 [XML_SCHEMA2]의 첨부 F 에 정의되어 있다. 인풋의 포맷이 응시자에게 명확하게 하는 점에, 특히 응답의 유효성 확인이 테스트를 통한 진행에 필요할 때, 주의가 필요하다.

<strong>속성(Attribute) : </strong>placeholderText [0..1]: string

시각적 환경에서, 문자열 interaction은 대개 응시자가 쓰거나 또는 입력하는 빈 박스로 표현된다. 그러나. 대화 기반(speech based) 환경에서는, interaction을 음성화 하기 위해 사용될 수 있는 개체틀 텍스트(placeholder text)를 갖는 것이 도움이 된다. 전송 엔진은 이것이 필요할 때 기본값 개체틀 텍스트 대신 이러한 속성값(제공되는 경우)을 사용해야 한다. 실행자들은 응답 변수(response variables) 절에서 설명된 기본값 사용에 관한 내용에 대해 명심하고 있어야 한다.

<strong>클래스(Class) :</strong> textEntryInteraction (inlineInteraction, stringInteraction)

textEntryInteraction은 응시자의 간단한 텍스트 일부를 취하는 inlineInteraction의 일종이다. inlineChoiceInteraction 처럼, 전송 엔진은 응시자로 하여금 주변 텍스트의 문맥(context) 내에서 그들의 선택 문항을 검토할 수 있도록 해야 한다.

textEntryInteraction은 단일 다중성(single cardinality) 만을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다. baseType은 반드시 'string', 'integer', 'float' 중 하나여야 한다.

<strong>클래스(Class) :</strong> extendedTextInteraction (blockInteraction, stringInteraction)

extendedTextInteraction은 응시자가 확장된 텍스트를 입력할 수 있도록 해주는 blockInteraction이다.

extendedTextInteraction은 'string', 'integer', 'float'의 baseType 을 갖는 응답 변수(response variable)에 바인딩되어 있어야한다. 단일 다중성(single cardinality)을 갖는 응답 변수(response variable)에 바인딩 된 경우, 텍스트의 단일 문자열이 응시자로부터 요구된다. 다중(multiple) 또는 순서화된 다중성(ordered cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있는 경우, 여러 개의 분리된 텍스트 스트링이 요구될 수 있다. 아래 maxStrings참조

<strong>속성(Attribute) : </strong>maxStrings [0..1]: integer

maxStrings 속성이 요구되는 경우는 interaction이 컨테이너 응답 변수(response variable)에 바인딩되어 있을 때이다. 전송 엔진(delivery engine)은 응시자로부터 받아 들여진 분리 문자열의 최대 숫자를 통제하기 위해 이 속성을 사용해야 한다. 다중 문자열이 받아 들여진 경우, expectedLength가 각 문자열에 적용된다.

<strong>속성(Attribute) : </strong>minStrings [0..1]: integer = 0

minStrings 속성은 유효 응답을 형성하기 위해 응시자에게 요구되는 개별(비어있지 않은, non-empty) 문자열의 최소 숫자를 지정한다. minStrings가 0 이면, 응시자는 문자열을 입력 할 필요가 없다. minStrings은 maxStrings가 지정한 한계보다 작거나, 동일해야 한다. 만약 interaction이 컨테이너에 묶여 있지 않다면, minStrings가 1 이 될 수도 있는 특수한 경우도 있다. 이 경우 응시자는 유효 응답을 형성하기 위해 반드시 비어있지 않은(non-empty) 문자열을 입력해야 한다. patternMask 속성으로 문자열 양식에 대한 보다 복잡한 제약을 제어할 수 있다.

<strong>속성(Attribute) : </strong>expectedLines [0..1]: integer

expectedLines 속성은 입력 라인에 필요한 예상 숫자에 관한 힌트를 응시자에게 제공한다. 전송 엔진(delivery engine)은 적용 가능한 경우 이 속성값을 사용하여 응답 박스의 크기를 설정해야 한다. 이는 유효성 제약은 아니다.

<strong>속성(Attribute) : </strong>format [0..1]: textFormat = plain

응시자가 입력한 텍스트 포맷을 제어하기 위해 사용된다. 아래 textFormat 참조. 이 속성은 연결 변수 값이 응답 처리 엔진에 의해 해석되는 방법에 영향을 주며, 또한 그 값이 전송 엔진에서 캡쳐되는 방법을 제어한다.

<strong>열거(Enumeration)</strong> : textFormat

plain

응시자가 입력할 텍스트가 플레인 텍스트(plain text) 임을 나타낸다. 이 포맷은 일정한 체계가 없는 짧은 응답에 적합하다. 전송 엔진은 응답이 흰색 공백문자(white-space character)로만 이루어져 있는 경우를 제외하고, 응시자 인풋의 흰색 공백 문자를 간직해야 하며, 이 경우 응답은 NULL 로 취급되어야 한다.

preFormatted

응시자가 입력할 텍스트가 사전에 포맷되었으며 [XHTML]의 'pre' 정의에 일치하는 방법으로 변경되어야 함을 의미한다. 전송 엔진은 응답이 흰색 공백 문자(white-space character)로만 이루어져 있는 경우를 제외하고, 응시자 입력의 흰색 공백 문자를 간직해야 하며, 이 경우 응답은 NULL 로 취급되어야 한다.

xhtml

응시자가 입력할 문자가 체계가 있는 텍스트라는 의미이다. 응답 변수(response variable) 값은 XHTML 에서 표시된 텍스트이다. 전송 엔진은 체계있는 텍스트를 캡쳐하기에 적절한 인터페이스를 제시할 것이며, 이는 위키 페이지 편집기 또는 완전한 WYSIWYG 편집기에서 사용되는 것과 같이, 간단한 텍스트 마크업 규칙 세트와 함께 해석되는 평문 텍스트일 수 있다.

<strong>클래스(Class) :</strong> hottextInteraction (blockInteraction)

hottextInteraction은 응시자에게 간단한 텍스트 단락 등과 같이 주변 문맥(context) 내에 삽입된 선택가능한 textRun으로써 표시되는 선택 문항 세트를 제시한다. choiceInteraction과 같이, 응시자의 할 일은 maxChoices 최대 갯수까지 하나 이상의 선택 문항을 고르는 것이다. interaction은 연결 응답 변수(response variable)의 defaultValue로부터 초기화 되는데, 이 값은 문항이 선택되지 않았음(일반적인 경우)을 의미하는 NULL 값이다.

hottextInteraction은 반드시 식별자(identifier) baseType과 단일(single) 또는 다중 중복성(multiple cardinality)를 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>maxChoices [1]: integer = 1

응시자가 선택할 수 있는 최대 선택 문항 수. matchChoices가 0 이면, 제약이 없음을 의미하며, 1 (또는 0) 보다 크다면, interaction은 다중 중복성(multiple cardinality)을 갖는 응답에 반드시 묶여 있어야 한다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer = 0

유효 응답을 형성하기 위해 응시자가 선택하도록 요구되는 최소 선택 문항 수. minChoices가 0 이면, 응시자는 선택 문항을 선택할 필요가 없다. minChoices는 maxChoices가 지정한 한계보다 작거나 동일해야 한다.

<strong>포함(Contains) :</strong> blockStatic [1..*]

상호작용 콘텐츠는, 콘텐츠의 한 조각이라고 할 수 있으며, hottext 영역을 포함하는 텍스트 한 단락이 그 예라고 할 수 있다

<strong>클래스(Class) :</strong> hottext (choice, flowStatic, inlineStatic)

hottext 영역은 개별 선택 문항을 제공하는 hottextInteraction 콘텐츠 내에서 사용되며, 어떠한 중첩 interaction 또는 다른 hottext 영역을 포함할 수 없다.

hottext 선택 문항이 숨김상태 일때 (연결 템플릿 변수 값에 의해), 선택 문항의 콘텐츠는 단순히 주변 자료의 일부인 것처럼 여전히 응시자에게 제시되어야 한다. hottext의 경우, 선택 문항의 숨김이 갖는 효과는 응시자의 선택이 가능한 textRun을 만드는 것이다.

포함(Contains) : inlineStatic [*]

</div>
<div id="sec_7.3" class="section">
<h3><a name="7.3">7.3 그래픽 상호작용</a></h3>
<strong>추상 </strong><strong>클래스(Abstract class) :</strong>hotspot

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : associableHotspot, hotspotChoice

일부의 그래픽 interaction은 특수하게 정의된 영역 또는 hotspots을 갖는 이미지를 수반한다.

<strong>속성(Attribute) : </strong>shape [1]: shape

hotspot의 shape

<strong>속성(Attribute) : </strong>coords [1]: coords

hotspot의 크기 및 포지션. shape와 함께 해석된다.

<strong>속성(Attribute) : </strong>hotspotLabel [0..1]: string256

이미지의 이(hot) 영역을 위한 대체 텍스트로, 지정된 경우, img 대체 텍스트와 같은 방식으로 취급되어야 한다.

<strong>클래스(Class) :</strong> hotspotChoice (choice, hotspot)

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: hotspotInteraction, graphicOrderInteraction

<strong>클래스(Class) :</strong> associableHotspot (associableChoice, hotspot)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : graphicAssociateInteraction, graphicGapMatchInteraction

<strong>속성(Attribute) : </strong>matchMax [1]: integer

이 선택 문항이 연결되어 있는 최대 선택 문항 수. matchMax가 0 이면, 제약이 없다는 의미이다.

<strong>속성(Attribute) : </strong>matchMin [0..1]: integer = 0

유효 응답을 형성하기 위해 이 선택 문항이 연결되어 있는 최소 선택 문항 수. matchMin가 0 이면, 응시자는 이 선택 문항을 다른 것과 연결할 필요가 없다. matchMin은 matchMax가 지정한 한계보다 작거나 동일해야 한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>graphicInteraction (blockInteraction)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : graphicAssociateInteraction, graphicGapMatchInteraction, graphicOrderInteraction, hotspotInteraction, selectPointInteraction

<strong>포함(Contains) :</strong> object [1]

각 그래픽 interaction은 type 속성이 지정한 이미지 형식 객체로 주어진 연결 이미지를 반드시 갖고 있어야 한다.

<strong>클래스(Class) :</strong> hotspotInteraction (graphicInteraction)

hotspotInteraction은 그래픽 이미지의 영역으로 정의되는 선택 문항 해당세트를 갖고 있는 그래픽 interaction이다. 응시자가 할 일은 하나 또는 그 이상의 이 영역(hotspots)을 선택하는 것이다. hotspotInteraction은 서로(그래픽 이미지에서 보여지듯)에 관한 선택 문항의 공간적 관계가 문항의 니즈에 중요할 때에만 사용되어야 한다. 그렇지 않다면, choiceInteraction이 각 옵션에 대한 개별 자료와 함께 대신 사용되어야 한다.

전송 엔진은 반드시 이미지의 선택 영역(들)을 명확하게 나타내야 하며, 또한 선택되지 않은 영역까지도 나타낼 수 있다. 숨김 상태의 hotspots을 갖는 interactions은 selectPointInteraction과 함께 실행된다.

hotspotInteraction 은 반드시 식별자(identifier) baseType과 단일(single) 또는 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>maxChoices [1]: integer = 1

응시자가 선택 가능한 최대 선택 문항 수. maxChoices가 0 이면, 제약이 없음을 의미하며, 1 (또는 0) 보다 크다면, interaction은 다중 중복성(multiple cardinality)을 갖는 응답에 반드시 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer = 0

유효 응답을 형성하기 위해 응시자가 선택하도록 요구되는 최소 선택 문항 수. minChoices가 0 이면, 응시자는 선택 문항을 고를 필요가 없다. minChoices는 maxChoices가 지정한 한계보다 작거나 동일해야 한다.

<strong>포함(Contains) :</strong> hotspotChoice [1..*] {ordered}

응시자가 선택할 수 있는 선택 문항을 정의하는 hotspots. 전송 시스템이 포인트 기반 선택을 지원하지 않으면, 선택 문항이 주어지는 순서는 반드시 응시자가 선택하도록 제시되는 순서이어야 한다. 예를 들어, 단순한 키보드 탐색의 “tab order”와 같다. hotspots이 겹치면, 목록 첫 번째에 있는 hotspots이 이후에 나타나는 hotspots을 가린다. Hotspot 기본값이 지정되어 있다면 마지막에 나타난다.

<strong>클래스(Class) :</strong> selectPointInteraction (graphicInteraction)

hotspotInteraction과 마찬가지로, selectPointInteraction은 그래픽 상호작용이다. 응시자가 할 일은 하나, 또는 그 이상의 포인트를 고르는 것이다. 연결 응답은 미리 지정된 영역에 대한 비교를 기초로 응답을 채점하는 areaMapping을 가질 수도 있으나, 전송 엔진은 이미지의 이 영역들을 나타내서는 안된다. 응시자가 고른 실제 포인트만이 표시된다.

selectPointInteraction은 반드시 포인트(point) baseType과 단일(single) 또는 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>maxChoices [1]: integer = 1

이 속성은 응시자가 선택할 수 있는 포인트의 최대 숫자로 해석된다. maxChoices이면 제약이 없다는 뜻이며, 1 (또는 0) 보다 큰 경우, interaction은 반드시 다중 중복성(multiple cardinality)을 갖는 응답에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer = 0

유효 응답을 형성하기 위해 응시자가 선택해야만 하는 포인트 최소 숫자. minChoices 가 0 인 경우, 응시자는 포인트를 선택할 필요가 없다. minChoices는 maxChoices. 에 의해 지정된 한계보다 작거나 동일해야 한다.

<strong>클래스(Class) :</strong> graphicOrderInteraction (graphicInteraction)

graphicOrderInteraction은 그래픽 이미지의 영역으로 정의되는 선택 문항의 해당 세트를 갖는 그래픽 상호작용이다. 응시자가 할 일은 이 영역(hotspots)에 대한 배열을 지정하는 것이다. 순차적 핫스팟 상호작용(ordered hotspot interaction)은 서로(그래픽 이미지에서 보여지듯)에 관한 선택 문항의 공간적 관계가 문항의 니즈에 중요할 때에만 사용되어야 한다. 그렇지 않다면, orderInteraction이 각 옵션에 대한 개별 자료와 함께 대신 사용되어야 한다.

전송 엔진은 이미지의 모든 지정된 영역을 명확하게 나타내야 한다.

순차적 핫스팟 상호작용(ordered hotspot interaction)은 반드시 식별자(identifier) baseType과 순차적 다중성(ordered cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>포함(Contains) :</strong> hotspotChoice [1..*]

응시자가 지정하는 순서의 선택 문항을 정의하는 핫스팟. 전송 시스템이 포인트 기반 선택을 지원하지 않으면, 선택 문항이 주어지는 순서는 반드시 응시자가 선택하도록 제시되는 순서라야 한다. 예를 들어, 단순한 키보드 탐색의 “tab order” 이다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer

상호작용에 대한 유효응답을 형성하기 위해 응시자가 선택하고 정렬해야 하는 선택 문항의 최소 숫자. 지정된 경우 minChoices는 1이거나 그보다 커야 하지만, 가능한 선택 문항 숫자보다 많을 수 없다. 지정되지 않은 경우, 모든 선택 문항은 순차적으로 정렬되어야 하며, maxChoices는 무시된다.

<strong>속성(Attribute) : </strong>maxChoices [0..1]: integer

상호작용에 응답할 때 응시자가 선택하거나 또는 정렬하는 선택 문항의 최대 숫자. minChoices와 함께 사용되며, 지정된 경우, maxChoices는 minChoices 보다 크거나 이와 동일해야 하며, 가능한 선택 문항 숫자보다 많을 수 없다. 지정되지 않은 경우, 모든 선택 문항이 순차적으로 정렬될 수 있다.

<strong>클래스(Class) :</strong> graphicAssociateInteraction (graphicInteraction)

graphicAssociateInteraction은 그래픽 이미지의 영역으로 정의되는 선택 문항의 해당 세트를 갖는 그래픽 상호작용(graphic interaction) 이다. 응시자가 할 일은 이 영역을(hotspots) 서로 연결하는 것이다. graphicAssociateInteraction은, 서로(그래픽 이미지에서 보여지듯)에 관한 선택 문항의 그래픽 관계가 문항의 니즈에 중요할 때에만 사용되어야 한다. 그렇지 않다면, associateInteraction이 각 옵션에 대한 개별 자료(material)와 함께 대신 사용되어야 한다.

전송 엔진은 이미지의 모든 지정된 영역을 명확하게 나타내야 한다.

순차적 핫스팟 상호작용(ordered hotspot interaction)은 반드시 기본 유형 쌍(base-type pair)과 단일(single) 또는 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>maxAssociations [1]: integer = 1

응시자가 만들 수 있도록 허용된 연결(association)의 최대 숫자. maxAssociations이 0 인 경우, 제약이 없으며, 1 (또는 0) 보다 큰 경우, 상호작용(interaction)은 다중 중복성(multiple cardinality)을 갖는 응답에 바인딩되어 있어야 한다.

<strong>포함(Contains) :</strong> associableHotspot [1..*]

응시자가 연결하는 선택 문항을 정의하는 핫스팟(hotspots). 전송 시스템이 포인트 기반 선택을 지원하지 않으면, 선택 문항이 주어지는 순서는 반드시 응시자가 선택하여 제시되는 순서라야 한다. 예를 들어, 단순한 키보드 탐색의 ‘tab order”와 같다. 예를 들어, 단순한 키보드 탐색의 “tab order” 이다.

<strong>클래스(Class) :</strong> graphicGapMatchInteraction (graphicInteraction)

graphicGapMatchInteraction은 그래픽 이미지의 영역으로 정의되는 gap 집합과, 이미지 밖의 것으로 정의되는 gap 선택 문항의 추가 세트를 갖는 그래픽 상호작용이다. 응시자는 이미지 안의 gap을 갖는 gap 선택 문항들을 연결해야 하며, 선택 문항에 표시된 대로, 콘텍스트 안에서 채워진 gap을 갖는 그 이미지를 검토할 수 있어야 한다. 이미지 안의 gap이 요청된 gap 선택 문항을 받기에 적절한 크기가 될 수 있도록 이들 interaction을 구성할 때에는 각별한 주의가 필요하다. 연결된 경우, 선택 문항들은 가능하다면 전적으로 gap 안에서만 나타나야 하며, 또 겹침이 필요한 곳에 이들 선택 문항들이 서로를 완벽하기 숨겨서는 안된다. 응시자가 선택 문항을 gap 너머에 위치시킴으로써(다시 말해, 드래그 앤 드롭) 연결을 표시하는 경우, 시스템은 이 선택 문항을 ‘snap” 하여 이들 요구사항을 만족시킬 수 있는 가장 가까운 자리로 옮겨야 한다.

graphicGapMatchInteraction은 기본 유형(base-type) 방향 쌍(directedPair)과 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다. 선택 문항들은 쌍(pairing)의 소스를 나타내며, 이미지 안의 gap(hotspots)은 목표를 나타낸다. 단순한 gapMatchInteraction과는 다르게, 각 gap은 그것과 연결된 다수의 선택 문항을 원하는 경우 가질 수 있으며, 더 나아가 동일한 선택 문항이 하나의 associableHotspot 과 여러 번 연결될 수 있다. 이 경우, 해당 방향 쌍(directedPair)이 응답 변수(response variable) 값 안에서 여러 번 나타난다.

<strong>포함(Contains) :</strong> gapImg [1..*]

gap을 채우기 위한 선택 문항의 순차적 목록. 필요한 경우, 선택 문항의 숫자가 gap 보다 작을 수 있다.

<strong>포함(Contains) :</strong> associableHotspot [1..*]

응시자에 의해 채워지는 gap을 정의 하는 hotspots. 전송 시스템이 포인트 기반 선택을 지원하지 않으면, 선택 문항이 주어지는 순서는 반드시 응시자가 선택하도록 제시되는 순서라야 한다. 예를 들어, 단순한 키보드 탐색의 ‘tab order” 과 같다. 예를 들어, 단순한 키보드 탐색의 ‘tab order” 이다. 기본값 hotspot은 지정되지 않아야 한다.

<strong>클래스(Class) :</strong> positionObjectInteraction (interaction)

관련 클래스(Associated classes) :

positionObjectStage

positionObjectInteraction은 응시자에 의해 다른 그래픽 이미지(단계)에 위치하는 단일 이미지로 구성된다. selectPointInteraction과 마찬가지로, 연결응답은 미리 지정된 영역에 대한 비교를 기초로 응답을 채점하는 areaMapping을 가질 수도 있으나, 전송 엔진은 이 단계의 이들 영역들을 나타내서는 안된다. 응시자가 고른 실제 포인트만이 표시된다.

positionObjectInteraction은 반드시 포인트 baseType과 단일(single) 또는 다중 중복성(multiple cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다. 그 단계에 관해, 포인트는, 위치가 정해지는 이미지의 중심 포인트의 좌표를 기록한다.

<strong>속성(Attribute) : </strong>centerPoint [0..2]: integer

centerPoint 속성은 가로, 세로 순서로 이미지의 상단 좌측 코너에서부터 오프셋(offset) 처럼, 증잉(center)으로 취급될 이미지의 자리배치에 대한 포인트를 정의한다. 기본적으로, 이것은 이미지 경계 사각형의 중심이다.

이미지가 배치된 그 단계는 여러 positionObjectInteractions 간에 공유될 수 있으며, 따라서 자체의 positionObjectStage 클래스 안에서 정의된다.

<strong>속성(Attribute) : </strong>maxChoices [1]: integer = 1

이미지가 배치될 수 있는 위치(position)의 최대 숫자. matchChoices가 0 이면, 제약이 없으며, 1 (또는 0) 보다 큰 경우, interaction은 반드시 다중 중복성(multiple cardinality)을 갖는 응답에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>minChoices [0..1]: integer

interaction에 대한 유효 응답을 형성하기 위해 이미지가 배치되어야 할 위치(position)의 최소 숫자. 지정된 경우, minChoices가 1 이거나 그보다 커야 하지만, maxChoices가 지정한 한계를 초과할 수 없다.

<strong>포함(Contains) :</strong> object [1]

응시자에 의해 단계(stage)에 위치하게 되는 이미지

<strong>클래스(Class) :</strong>positionObjectStage (block)

<strong>포함(Contains) :</strong> object [1]

단계(stage)로 사용될 이미지. 이 이미지 위에 개별 positionObjectInteractions는 응시자가 그들의 객체를 배치할 수 있도록 허용한다.

<strong>포함(Contains) :</strong> positionObjectInteraction [1..*]

</div>
<div id="sec_7.4" class="section">
<h3><a name="7.4">7.4 기타 상호작용</a></h3>
<strong>클래스</strong><strong>(Class) :</strong> sliderInteraction (blockInteraction)

sliderInteraction은 하위와 상의 바운드 사이의 숫자 값을 선택하는 제어를 응시자에게 제공한다. 정수(integer) 또는 플로트(float)의 기본 유형(base-type)을 갖는 단일 중복성(single cardinality)를 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성</strong><strong>(Attribute) : </strong>lowerBound [1]: float

연결 응답 변수(response variable)가 정수(integer) 유형이면, 하한(lowerBound)을 주어진 값보다 작거나 동일한 최대 정수(integer)까지 내림으로 계산한다.

<strong>속성</strong><strong>(Attribute) : </strong>upperBound [1]: float

연결 응답 변수(response variable)가 정수(integer) 유형이면, 상한(upperBound)을 주어진 값보다 작거나 동일한 최대 정수(integer)까지 올림으로 계산한다

<strong>속성(Attribute) : </strong>step [0..1]: integer

제어가 시작되는 단계(step). 예를 들어,상한(upper bound)과 하한(lower bound)이 [0,10], 이고 step 이 2 이면, 응답 값은 {0,2,4,6,8,10} 세트로 제한될 것이다. 만약 정수(integer) 응답에 바인딩되어 있으며, 기본값 단계(step)는 1 이며, 다르게 정의되지 않는 한 슬라이더(slider)는 대략 연속적인 스케일로 작동하는 것으로 간주된다.

<strong>속성(Attribute) : </strong>stepLabel [0..1]: boolean = false

기본적으로, 슬라이더(sliders)는 마지막에서만 레이블(label) 된다. stepLabe 속성은 슬라이더 위의 각 단계(step)가 또한 레이블(label) 되어야 할 것인지 아닌지를 제어한다. 전송 엔진이 단계(steps) 에 레이블(label) 하도록 보장할 수 있을 것 같지 않으므로 이 속성은 오직 요청대로만 취급되어야 한다.

<strong>속성(Attribute) : </strong>orientation [0..1]: orientation

orientation 속성은 렌더링 시스템에 힌트를 제공하는데, 그 힌트는 슬라이더(slider)가 고유의 수직적(vertical) 또는 수평적(horizontal) 해석을 갖는 양의 값을 표시하기 위해 사용되고 있다는 것이다. 예를 들어, 높이 값을 표시하게 위해 사용되는 상호작용은 orientation을 수직으로 설정하여, 그것을 수평으로 변경하는 것은 문항 난이도를 거짓으로 높일 수 있다는 것을 나타낼 수 있다.

<strong>속성(Attribute) : </strong>reverse [0..1]: boolean

reverse 속성은 렌더링 시스템에 힌트를 제공하는데, 그 힌트는 슬라이더(slider) 가 일반적인 상한(upper bound)과 하한(lower bound)의 의미가 반대로 돌아가게 하는 양의 값을 표시하기 위해 사용되고 있다는 것이다. 예를 들어, 해저의 깊이를 표시하기 위해 사용되는 상호작용은 상한과 하한을 둘 다 수직 orientation으로 지정하고 reverse 속성을 설정할 수 있다.

슬라이더 상호작용은 연결 응답 변수(response variable)를 위한 기본값으로 지정된 경우를 제외하고, 기본값 또는 초기 포지젼을 갖지 않음을 명심한다. 현대 선택된 값은, 있다면, 반드시 응시자에게 분명하게 표시되어야 한다.

<strong>클래스(Class) :</strong> mediaInteraction (blockInteraction)

mediaInteraction은 응시자가 시간 기반 미디어 객체와 상호작용하는 방법에 대해 보다 많은 통제를 허용하며, 미디어 객체가 연결 응답 변수(response variable) 값 안에서 보고 되기 위해 사용되어야 하는 횟수를 허용하는데, 그 변수값은 반드시 기본 유형(base-type) 정수(integer) 와 단일 다중성(single cardinality) 이라야 한다.

<strong>속성(Attribute) : </strong>autostart [1]: boolean

autostart 속성은 미디어 객체가 응시자의 시도가 시작되자 마자 시작할 지(true), 또는 응시자의 통제에 의해 시작 되도록(false) 할 지를 결정한다.

<strong>속성(Attribute) : </strong>minPlays [0..1]: integer = 0

minPlays 속성은 미디어 객체가 응시자에 의해 실행되는 최소 숫자를 나타낸다. 이를 실행하는 기술은 시스템 마다 다르며, 일부 시스템에서는 이 속성이 불가능할 수도 있다. 기본적으로, 최저치는 없다. 미디어 객체의 최소 횟수 실행 실패는 유효하지 않은 응답을 구성한다.

<strong>속성(Attribute) : </strong>maxPlays [0..1]: integer = 0

maxPlays 속성은 미디어 객체가 많아야 maxPlays 횟수로 실행될 수 있다는 것을 의미한다. 응시자는 maxPlay 횟수 이상 미디어 객체를 실행할 수 없다. 0 값(기본값)은 제한이 없음을 의미한다.

<strong>속성(Attribute) : </strong>loop [0..1]: boolean = false

loop 속성은 연속 실행 모드를 설정하기 위해 사용된다. 이 연속 실행 모드에서, 미디어 객체가 일단 실행되기 시작하면, 계속해서 실행된다 (maxPlays의 영향을 받는다).

<strong>포함(Contains) :</strong> object [1]

미디어 객체 그 자체

<strong>클래스(Class) :</strong> drawingInteraction (blockInteraction)

drawing interaction은 응시자가 주어진 그래픽 이미지(the canvas)를 변형하기 위해 그리기 도구 공통 세트를 사용하도록 해준다. 기본 유형 파일(base-type file)과 단일 다중성(single cardinality)를 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다. 결과는 본래 이미지와 동일한 포맷의 파일이다.

<strong>포함(Contains) :</strong> object [1]

그림이 그려지는 캔버스 역할을 하는 이미지는, 유형(type) 속성에 의해 지정되는 것처럼 이미지(image) 타입의 객체로 주어진다.

<strong>클래스(Class) :</strong> uploadInteraction (blockInteraction)

upload interaction은 응시자가 응답을 나타내는 미리 준비된 파일을 업로드할 수 있도록 한다. 기본 유형 파일(base-type file)과 단일 다중성(single cardinality)를 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

<strong>속성(Attribute) : </strong>type [0..1]: mimeType

업로드한 파일의 예상 마임타입(mime-type)

<strong>클래스(Class) :</strong> customInteraction (block, flow, interaction)

customInteraction은 현재 기록되지 않은 상호작용을 위한 지원을 포함하는 이 표준의 확장 가능성에 대한 기회를 제공한다.

</div>
<div id="sec_7.5" class="section">
<h3><a name="7.5">7.5 시도를 종료할 수 있는 대안</a></h3>
<strong>클래스(Class) :</strong> endAttemptInteraction (inlineInteraction)

endAttemptInteraction은 상호작용의 특수 유형으로 문항 저작자가 응시자에게 시도를 종료하는 방법에 대한 통제를 제공할 수 있게 한다. 응시자는 이 상호작용을 사용하여 시도 종료(응답 처리를 시작하게)를 즉각적으로 할 수 있으며, 전형적으로 힌트를 요구한다. endAttemptInteraction은 반드시 기본 유형(base-type) 논리(boolean)와 단일 다중성(single cardinality)을 갖는 응답 변수(response variable)에 바인딩되어 있어야 한다.

응시자가 endAttemptInteraction을 사용하여 응답 처리를 발동하면, 연결 응답 변수(response variable)는 참(true)으로 설정된다. 응답 처리가 다른 방법으로, 다른 endAttemptInteraction을 통해서든 또는 전송 엔진을 위한 기본 방법(default method)을 통해서든 발동되면, 연결 응답 변수(response variable)는 'false'로 설정된다. 응답 변수(response variable)의 기본값은 항상 무시된다.

<strong>속성(Attribute) : </strong>title [1]: string

Interaction을 사용하여 시도를 종료하기 위한 프롬프트로 응시자에게 보여져야 하는 문자열. 이 문자열은 짧아야 하며, 한 단어가 선호된다. 전형적인 값으로는 "Hint"가 있다. 예를 들어, 그래픽 환경에서, 이 문자열은 버튼 위의 레이블로 나타나는 것으로, 이 버튼을 누르면 시도를 종료하는 것이 된다.

</div>
</div>
<!-- chap 7 -->
<div id="chap_8" class="chapter">
<h2><a name="8">8 응답 처리(Response Processing)</a></h2>
응답 처리란 전송 엔진이 응시자의 응답을 기초로 결과물을 지정하는 절차이다. 결과물은 응시자에게 피드백을 제공하기 위해 사용될 수 있다. 피드백은 응시자의 시도 종료 후 즉시 제공되거나, 문항 세션(item session)에 대한 요약 보고의 일부로 이후에 제공될 수도 있다.

시도가 종료되고 이어서 진행되는 응답 처리는, 사용자 행위에 대한 직접적인 응답이나 또는 테스트 종료와 같은 일부 예상된 상황에 대한 대응으로만 발생해야 한다. 중단 상태의 문항 세션(item session)은 아직 응답 처리 과정에 제출되지 않은 응답 변수(response variable) 값을 가졌을 수 있다.

비적응형 문항에 있어서, 결과 변수 값은 각각의 응답 처리 작동 전에 기본값으로(또는 기본값이 주어지지 않은 경우 0) 재설정 된다. 하지만, 전송 엔진은 비적응형 문항에 대한 응답 처리를 여러 번 작동시킬 수 있지만, 결과물의 첫 번 째 세트만 보고할 수 있으며, 시도 횟수는 이 표준의 범위 밖에서 합의되어 미리 정해진 한계치로 제한된다.

적응형 문항에 있어서, 결과 변수 값은 본래의 기본값으로 재설정되지 않는다. 적응형 문항을 원하는 전송 엔진은 반드시 응시자가 응답 처리를 위해 자신의 응답을 수정하고 제출할 수 있도록 허용해야 하며, 마지막으로 만들어진 결과 세트만을 보고해야 한다. 나아가, 응답문항은 반드시 적용가능한 모든 형식적인 피드백과 통합적인 피드백을 응시자에게 제시해야 한다. 이후의 응답 처리는 세션 결과를 업데이트 할 때 응시자에게 보여지는 피드백을 고려대상으로 삼을 수 있다. 적응형 문항은 전송 엔진에게 다음의 신호, 즉 응시자는 상호작용을 완료하였으며 포함형(built-in)결과 변수인 completionStatus을 완료상태로 설정함으로써 더 이상의 문항시도가 허용되지 않는다는 신호를 보낼 수 있다.
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_8.1.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-535 size-full" src="{{ "/assets/images/IMS-KR-1002-1_8.1.jpg" | absolute_url }}" alt="IMS KR 1002-1_8.1" width="454" height="514" /></a></div>
<p align="center">그림 8.1 추가 상호작용(interaction)을 뒤따르는 피드백</p>

<div id="sec_8.1" class="section">
<h3><a name="8.1">8.1 응답 처리 템플릿(Response Processing Templates)</a></h3>
응답 처리 과정에는 responseRules 집합이 활용되며, 또한 responseConditions 테스팅 그리고 문항 변수(item variable)를 수반하는 표현(expressions)에 대한 평가가 포함된다. 매우 단순한 사용 사례를 지원하기 위한 목적으로 설계된 전송 엔진의 경우, 평가, 조건적 테스팅, 프로세싱을 이행하기 위한 시스템 실행이 표준도입에 장애가 될 수 있다.

이러한 문제를 완화시키기 위해, 일반화된 응답 처리 작업 실행을 선택할 수 있다. 이를 지원하지 않는 엔진은 대신, 아래 설명된 응답 처리 템플릿(response processing templates) 이라고 불리는 표준 응답 처리 장치를 소수 실행시킬 수 있다. 이들 템플릿은 이 표준에서 정의된 프로세싱 언어를 사용해 설명될 수 있으며 표준과 함께(XML 양식으로) 배포된다. 일반화된 응답 처리를 지원하는 전송 엔진은 그들을 지원하기 위한 특수 매커니즘을 실행시킬 필요가 없으며, 이는 템플릿 파일이 그 파일을 참조하는 assessmentItem을 처리하는 동안 직접적으로 설명될 수 있기 때문이다.

일반화된 응답 처리를 지원하지는 않지만, 아래 설명된 표준 템플릿 이상의 기능을 하는 응답 처리 매커니즘을 지원하는 전송 엔진은 가능한 경우 자체 템플릿을 직접 지정해야 한다. 이 전송 엔진의 문항을 작성하고자 하는 저작자는 이와 같은 맞춤(custom) 템플릿을 참고할 수 있다. 이들 맞춤 템플릿을 실행(publishing)함으로써 이들 문항이 일반화된 응답 처리를 지원하지 않는 전송 엔진과 함께 사용될 수 있음을 확실히 보장하게 될 것이다.
<div id="sec_8.1.1" class="section">
<h4><a name="8.1.1">8.1.1 표준 템플릿(Standard Templates)</a></h4>
<strong>Match</strong><strong> Correct</strong> : rptemplates/match_correct.xml

전체 템플릿 URI: http://www.imsglobal.org/question/qtiv2p1pd2/rptemplates/match_correct

정답 매칭 처리 템플릿(match correct response processing template)은 match operator를 사용해서 응답 변수(response variable) RESPONSE의 값을 정답 값과 일치시키는 기능을 한다. 이 템플릿은 결과 변수 SCORE를 테스트 결과에 따라 0 또는 1로 설정한다. RESPONSE로 불리는 값을 갖는 응답 변수(response variable)는 선언되었을 것이며 연결 정답값을 갖는다. 마찬가지로 결과 변수 SCORE 또한 이미 선언되었을 것이다. 이 템플릿은 모든 baseType과 다중성(cardinality)의 응답에 적용되지만, 보다 복잡한 데이터 유형을 일치시키는 작업에 한계가 있음을 명심해야 한다. 이 템플릿은 기본 유형 플로트(base-type float)를 갖는 응답의 수가 서로 같은 지의 여부를 테스트 하기 위해 사용되어서는 안된다.

이 템플릿이 항상 SCORE 값을 설정한다는 점을 명심한다. 이는 RESPONSE가 주어지지 않는 경우에도 마찬가지이다.

<strong>Map Response :</strong> rptemplates/map_response.xml

전체 템플릿 URI: http://www.imsglobal.org/question/qtiv2p1pd2/rptemplates/map_response

응답 매핑 처리 템플릿(map response processing template)은 mapResponse operator를 사용하여 응답 변수(response variable) 값 RESPONSE를 결과값 SCORE에 매핑시킨다. mapResponse를 사용할 때 SCORE는 플로트(float) 유형일 필요가 있다. 두 변수 모두 선언되었을 것이며 RESPONSE는 연결 매핑(mapping)을 가졌을 것이다. 이 템플릿은 모든 baseType과 다중성(cardinality)의 응답에 적용된다. 이 템플릿이 컨테이너에 적용되었을 때의 작동에 관한 세부사항은 mapResponse에 관한 설명을 참조한다.

RESPONSE가 NULL 이면, SCORE는 0.0으로 설정된다.

<strong>Map </strong><strong>Response Point</strong><strong> : </strong>rptemplates/map_response_point.xml

전체 템플릿 URI: http://www.imsglobal.org/question/qtiv2p1pd2/rptemplates/map_response_point

응답 포인트 매핑 처리 템플릿(map response point processing template)은 mapResponsePoint operator를 사용하여 응답 변수(response variable) 값 RESPONSE를 결과값 SCORE에 매핑시킨다. 두 변수 모두 선언되었을 것이며 RESPONSE는 baseType 포인트(point)를 가졌을 것이다. 이 템플릿이 컨테이너에 적용되었을 때의 작동에 관한 세부사항은 mapResponsePoint 에 관한 설명을 참조한다.

RESPONSE가 NULL 이면, SCORE 는 0.0으로 설정된다.

</div>
</div>
<div id="sec_8.2" class="section">
<h3><a name="8.2">8.2 일반화된 응답 처리(Generalized Response Processing)</a></h3>
<strong>클래스(Class) :</strong> responseProcessing

관련 클래스(Associated classes) :

assessmentItem

<strong>속성(Attribute) : </strong>template [0..1]: uri

템플릿 식별자가 주어진 경우, 이 속성은 외부에서 정의된 responseProcessing 템플릿의 위치를 찾기 위해 사용될 수 있다. 이 외부 템플릿에서 취한 규칙들은 문항 자체 내에서 정의된 규칙들을 대신해 사용될 수도 있다. 다만, 두 규칙이 모두 주어진 경우, 내부 규칙 사용이 선호된다.

<strong>속성(Attribute) : </strong>templateLocation [0..1]: uri

실제로, template 속성은 URN이나 또는 이 표준에서 지정된 표준 응답 처리 템플릿과 같은 원거리 웹서버에 저장된 템플릿의 URI를 포함하고 있다고 해도 무방하다. assessmentItem를 처리할 때 오프라인에서 작동하는 도구는 URN이나 원거리에 있는 URI의 템플릿을 도출할 수 없을 것이다. 이러한 templateLocation 속성은 대체 URI를 제공하는데, 대체적으로 assessmentItem 자체의 위치와 관련해 결정되는 관계 URI가 바로 그것이며, 이것은 응답 처리 템플릿의 사본을 얻기 위해 사용될 수 있다. 만약 전송 시스템이 템플릿 식별자 하나만으로 맞는 행동을 결정할 수 없다면, templateLocation은 무시되어야 한다. 예를 들어, 전송 시스템은 위에서 정의된 표준 템플릿을 다룰 수 있는 내장된(built-in) 절차를 갖추었을 수 있다.

<strong>포함(Contains) :</strong> responseRule [*]

응시자가 지정하여 문항 결과 변수의 적절한 값으로 정해진 응답 변수(response variable) 값을 매핑하는 데는 많은 규칙이 따른다.
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_8.2.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-536 size-full" src="{{ "/assets/images/IMS-KR-1002-1_8.2.jpg" | absolute_url }}" alt="IMS KR 1002-1_8.2" width="451" height="605" /></a></div>
<p align="center">그림 8.2 응답 처리.</p>
<strong>추상 </strong><strong>클래스(Abstract class) :</strong>responseRule

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : exitResponse, include, lookupOutcomeValue, responseCondition, responseProcessingFragment, setOutcomeValue

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : responseElse, responseProcessingFragment, responseIf, responseProcessing, responseElseIf

응답 규칙은 responseCondition, 단순 액션, responseProcessingFragment 중의 하나다. 응답 규칙은 응답에서 결과를 도출하기(즉, 채점) 위해 필요한 경량 프로그래밍 언어를 지정한다. 이 프로그래밍 언어가 최소 숫자의 제어구조(control structure)를 포함하고 있으며, 보다 복잡한 채점 규칙은 반드시 다른 언어로 코딩되어야 하며 customOperator 사용하기를 참조한다.

<strong>클래스(Class) :</strong> responseCondition (responseRule)

<strong>포함(Contains) :</strong> responseIf [1]

<strong>포함(Contains) :</strong> responseElseIf [*]

<strong>포함(Contains) :</strong> responseElse [0..1]

만약 responseIf 또는 responseElseIf에서 주어진 표현이 참(true)으로 평가되면, 그 안에 포함된 하위 규칙들이 이어서 따라오며, 이하의 모든 responseIf 또는 responseElseIf 부분들은 이번 응답 조건(response condition)에서는 무시된다.

만약 responseIf 또는 responseElseIf에서 주어진 표현이 참(true)으로 평가되지 않으면, 고려사항은 다음 responseElseIf로 진행되거나, 또는 만약 더 이상의 responseElseIf 부분이 없다면, responseElse의 하위 규칙들이 뒤를 잇는다(지정된 경우).

<strong>클래스(Class) :</strong> responseIf

관련 클래스(Associated classes) :

responseCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> responseRule [*]

responseIf 부분은 표현식(expression)으로 이루어 지는데, 이 표현은 반드시 유효한 baseType으로 된 논리(boolean) 및 단일 다중성(single cardinality)를 갖추어야 한다. 적용된 런타임 데이터 모델에 관한 정보는 표현(expressions)을 참조한다. 이 부분은 또한 하위 규칙 세트를 포함한다. 만약 표현이 참(true) 인 경우, 하위 규칙이 진행되는데, true 가 아니었다면 이들 하위 규칙은 모두 건너띄어지며(표현이 NULL 값인 경우를 포함하여), 뒤를 잇는 responseElseIf 또는 responseElse 부분이(있는 경우) 대신 고려된다.

<strong>클래스(Class) :</strong> responseElseIf

관련 클래스(Associated classes) : responseCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> responseRule [*]

responseElseIf는 responseIf와 동일한 방법으로 정의된다.

<strong>클래스(Class) :</strong>responseElse

관련 클래스(Associated classes) : responseCondition

<strong>포함(Contains) :</strong> responseRule [*]

<strong>클래스(Class) :</strong> setOutcomeValue (outcomeRule, responseRule)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

설정될 결과 변수

<strong>포함(Contains) :</strong> expression [1]

설정 중인 결과 변수의 기본 유형(base-type)과 다중성(cardinality)에 일치하는 유효한 baseType과 다중성(cardinality)을 갖고 있어야 하는 표현식(expression)이다.

setOutcomeValue 규칙을 통해 관련 표현에서 도출된 값에 결과 변수 값이 설정된다. 결과 변수는 이전에 지정된 값을 참조하여 업데이트 될 수 있다. 다시 말해 설정 중인 결과 변수는 그 변수가 이전에 지정된 값을 취하는 표현(expression)에 나타날 수 있다는 뜻이다.

숫자형 기본 유형(base-types)을 사용 시에 각별한 주의가 요구되며, 이는 부동 소수점(floating point) 값이 정수 변수에 지정될 수 없으며 그 반대의 경우도 마찬가지이기 때문이다. truncate, round, 또는 integerToFloat 오퍼레이터는 숫자형 변환을 위해서만 사용되어야 한다.

<strong>클래스(Class) :</strong> lookupOutcomeValue (outcomeRule, responseRule)

lookupOutcomeValue 규칙은 결과 변수 값을, 결과 선언에 연결된 lookupTable 안에 있는 연결 표현(expression) 값을 찾음으로써 얻은 값에 설정한다.

<strong>속성(Attribute) : </strong>identifier [1]: identifier

설정될 결과 변수

<strong>포함(Contains) :</strong> expression [1]

단일 다중성(single cardinality) 및 정수(integer), 플로트(float), 실행시간(duration) 중 하나의 유효한 baseType을 갖고 있어야 하는 표현식(expression). 연결 표가 matchTable일 때 정수 유형이 필요하다.

<strong>클래스(Class) :</strong> exitResponse (responseRule)

exitResponse 규칙이 지정되면 응답 처리는 즉시 종료된다(해당 요청에 대해서).

</div>
</div>
<!-- chap 8 -->
<div id="chap_9" class="chapter">
<h2><a name="9">9 형식적인 피드백(Modal Feedback)</a></h2>
<strong>클래스(Class) :</strong> modalFeedback

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentItem

형식적인 피드백은 응답 처리 후 응시자에게 제시된다. 결과 변수 값은 showHide와 식별자(identifier) 속성과 함께 사용되어 이 피드백이 feedbackElement 와 유사한 방법으로 보여질 것인가를 결정한다.

<strong>속성(Attribute) : </strong>outcomeIdentifier [1]: identifier

<strong>속성(Attribute) : </strong>showHide [1]: showHide

<strong>속성(Attribute) : </strong>identifier [1]: identifier

<strong>속성(Attribute) : </strong>title [0..1]: string

전송 엔진은 응시자에게 타이틀을 반드시 보여줄 의무는 없으나, 보여줄 수도 있다. 팝업 윈도우의 타이틀이 그 예이다.

<strong>포함(Contains) :</strong> flowStatic [*]

modalFeedback 의 콘텐츠는 어떠한 interactions도 포함할 수 없다.

</div>
<!-- chap 9 -->
<div id="chap_10" class="chapter">
<h2><a name="10">10 문항 템플릿(Item Templates)</a></h2>
문항 템플릿이란, 많은 수의 유사 문항을 생성하기 위해 사용될 수 있는 템플릿을 말한다. 이러한 문항들은 종종 복제 문항(cloned item)이라고도 불린다. 문항 템플릿은 특수 목적 복제 엔진(Cloning Engine)에 의해 문항을 생성하기 위해 사용되거나, 또는 전송 엔진이 지원하는 경우 문항 세션(item session) 시작 시에 다이내믹 하게 선택된 복제 문항을 직접 생성하기 위해서도 사용될 수 있다.

하나의 문항 템플릿에서 복제된 각각의 문항은 템플릿 변수 세트에 주어진 값들만을 제외하곤 모두 동일하다. 따라서 하나의 assessmentItem은 그것이 하나 또는 그 이상의 templateDeclarations과 그들에게 값을 지정하기 위한 templateProcessing 규칙 세트를 포함한다면 하나의 문항 템플릿이 되는 셈이다.

복제 문항을 생성하는 복제 엔진(cloning engine)은 반드시 각각의 복제에 다른 식별자(identifier)를 지정해야 하며, 그 복제를 생성하기 위해 사용된 템플릿 변수값을 기록해야 한다. 이러한 복제 문항을 갖는 문항 세션(item session)에 대한 보고는, 그 문항 템플릿의 식별자(identifier)를 복제 문항의 식별자(identifier)로 교체하고 보고서에 템플릿 변수 값을 추가함으로써 본래의 문항 템플릿에 대한 보고와 동일한 것으로 변환될 수 있다.

<strong>클래스(Class) :</strong> templateDeclaration (variableDeclaration)

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentItem

템플릿 선언은 특수하게 문항 복제라는 목적을 위해 사용될 문항 변수(item variable)를 선언한다. 이들 선언은 templateProcessing 기간 중에만 그 값이 설정될 수 있다. 그 복제를 개별화 하기 위한 목적으로 템플릿 선언은 itemBody내부에서 언급되며, 또한 복제 처리가 문항을 채점하는 방법에 영향을 미치는 경우에, responseProcessing 규칙 내부에서도 언급될 수 있다.

문항 변수(item variable)는 문항 세션(item session)의 일부로 시작된다. 이들의 값은 templateProcessing에 초기화 되는데 이후에는 세션 내에서 상수(constant)의 기능을 수행한다.

<strong>속성(Attribute) : </strong>paramVariable [0..1]: boolean = false

이 속성은 템플릿 변수 값이 그 이름에 일치하는 객체 파라미터 값들을 대체해 사용되어야 하는 가를 결정한다. 상세 정보는 파라미터(param) 참조

<strong>속성(Attribute) : </strong>mathVariable [0..1]: boolean = false

이 속성은 템플릿 변수 값이 MathML 표현(expression)에서 이름에 일치하는 객체 식별자들을 대체해 사용되어야 하는 가를 결정한다. 상세 정보는 템플릿 변수와 MathML 묶기(Combining Template Variables and MathML) 참조
<div id="sec_10.1" class="section">
<h3><a name="10.1">10.1 문항 본문(Item’s body) 에서 템플릿 변수 사용하기</a></h3>
템플릿 변수는 문항 본체(item body) 안의 printedVariable 객체에 의해 참조될 수 있다. 이 템플릿 변수 값은 화면이 나타나는 적절한 textRun을 생성하는 데에도 사용된다. 템플릿 변수들은 또한 두 개의 templateElements을 통해 feedbackElements를 갖는 결과 변수들에게 하는 것과 유사한 방법으로 콘텐츠를 조건적으로 제어할 수 있다. 마지막으로, 템플릿 변수들은 interaction 내 선택(choice)들의 가시성 제어에도 사용될 수 있다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>templateElement (bodyElement)

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : templateBlock, templateInline

<strong>속성(Attribute) : </strong>templateIdentifier [1]: identifier

identifier의 기본 유형(base-type)을 가지면서 단일(single) 또는 다중 중복성(multiple cardinality) 중의 하나인 템플릿 변수의 식별자를 말한다. templateElement의 가시성은 변수값에 의해 제어된다.

<strong>속성(Attribute) : </strong>showHide [1]: showHide = show

<strong>속성(Attribute) : </strong>identifier [1]: identifier

showHide 및 identifier 속성은 어떠한 방법으로 templateElement의 가시성이 feedbackElement의 유사하게 이름 붙여진 showHide와 identifier 속성과 동일한 방식으로 제어되는지의 여부를 결정한다.

템플릿 요소는 직접적으로든 간접적으로든 어떠한 interaction도 포함할 수 없다.

<strong>클래스(Class) :</strong> templateBlock (blockStatic, flowStatic, templateElement)

<strong>포함(Contains) :</strong> blockStatic [*]

<strong>클래스(Class) :</strong> templateInline (flowStatic, inlineStatic, templateElement)

<strong>포함(Contains) :</strong> inlineStatic [*]

</div>
<div id="sec_10.2" class="section">
<h3><a name="10.2">10.2 오퍼레이터의 속성 변수 내에서 템플릿 변수 사용하기</a></h3>
표현(expressions)에 사용된 일부 operator는 자체 행동을 제어하는 속성을 갖는다. operator 자체가 평가되는 순간에 평가되는 템플릿 변수값은 해당 속성값(value of some such attributes)으로 사용될 수 있으며, 이는 속성의 타겟 유형이 갖는 공간 값(value space) 대신에 적절한 baseType 과 다중성(cardinality)의 템플릿 변수를 참조(reference)함으로써 가능하다. 이러한 속성값 대체 유형을 지원하는 속성은 다음 유형 중의 하나와 함께 선언된다.

변수 참조(reference)들을 문자열로 바인딩 할 때, 변수의 식별자는 반드시 중괄호로 묶여야 한다. 예를 들어, 문자열 "{myVariable}" 은 식별자 myVariable을 갖는 템플릿 변수를 참조한다. 참조(reference)는 반드시 해당 templateDeclaration내의 식별자와 일치해야 한다.

<strong>데이터유형(Datatype)</strong> : integerOrTemplateRef

기본형 정수(integer)와 단일 다중성(single cardinality)의 템플릿 변수값으로 교체될 수 있는 정수(integer) 유형의 속성에 사용되는 유형

<strong>데이터유형(Datatype) </strong>: floatOrTemplateRef

기본형 플로트(float) 와 단일 다중성(single cardinality)의 템플릿 변수값으로 교체될 수 있는 플로트(float) 유형의 속성에 사용되는 유형.

<strong>데이터유형(Datatype) </strong>: stringOrTemplateRef

기본형 문자열(string) 와 단일 다중성(single cardinality)의 템플릿 변수값으로 교체될 수 있는 문자열(string) 유형의 속성에 사용되는 유형.

템플릿 참조(reference)가 문자열에 바인딩될 때(앞서 설명된 의무 바인딩을 사용하여), 잠재적인 모호성이 존재한다. 따라서. 만약 문자열(string) 속성이 템플릿 변수에 대한 참조(reference)인 것으로 보이지만 주어진 이름을 갖는 변수가 없을 때, 문자열 속성은 단순한 문자열 값으로 처리되어야 한다.

</div>
<div id="sec_10.3" class="section">
<h3><a name="10.3">10.3 템플릿 처리(Template Processing)</a></h3>
<strong>클래스(Class) :</strong> templateProcessing

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentItem

<strong>포함(Contains) :</strong> templateRule [1..*]

템플릿 처리는 값을 템플릿 변수에 지정하기 위해 복제 엔진 또는 전송 시스템으로 이어지는 하나 또는 그 이상의 templateRule로 구성된다. 템플릿 처리는 형태면에 있어서 responseProcessing과 동일하며, 다만 그 목적이 값을 결과 변수가 아니라 템플릿 변수에 지정한다는 점이 예외이다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>templateRule

파생 클래스(Derived classes) :

exitTemplate, setCorrectResponse, setDefaultValue, setTemplateValue, templateCondition

관련 클래스(Associated classes) :

templateProcessing, templateElseIf, templateIf, templateElse

템플릿 규칙은 templateCondition이거나 단순 액션 중 하나이다. 템플릿 규칙은 복제 문항을 생성하기 위해 필요한 경량 프로그래밍 언어(light-weight programming language)를 정의한다. 이 프로그래밍 언어가 최소 숫자의 제어구조(control structure)를 포함하고 있으며, 보다 복잡한 복제 규칙은 이 표준 범위를 벗어난다.

templateRule에서 사용된 표현(expression)은 응답 변수(response variable) 또는 결과 변수 값을 참조할 수 없으며, 템플릿 변수값 만을 참조할 수 있다.

<strong>클래스(Class) :</strong> templateCondition (templateRule)

<strong>포함(Contains) :</strong> templateIf [1]

<strong>포함(Contains) :</strong> templateElseIf [*]

<strong>포함(Contains) :</strong> templateElse [0..1]

만약 templateIf 또는 templateElseIf에서 주어진 표현이 참(true)으로 평가되면, 그 안에 포함된 하위 규칙들이 이어서 따라오며, 이하의 모든 templateElseIf 또는 templateElse 부분들은 이번 템플릿 조건(template condition)에서는 무시된다.

만약 templateIf 또는 templateElseIf에서 주어진 표현이 참(true)으로 평가되지 않으면, 고려사항은 다음 responseElseIf로 진행되거나, 또는 만약 더 이상의 templateElseIf 부분이 없다면, templateElse의 하위 규칙들이 뒤를 잇는다(지정된 경우).

<strong>클래스(Class) :</strong> templateIf

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : templateCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> templateRule [*]

templateIf 부분은 표현식(expression)으로 이루어 지는데, 이 표현은 반드시 유효한 baseType으로 된 논리(boolean) 및 단일 다중성(single cardinality)을 갖추어야 한다. 적용된 런타임 데이터 모델에 관한 정보는 표현(Expressions)을 참조한다. 이 부분은 또한 하위 규칙 세트를 포함한다. 만약 표현이 true 인 경우, 하위 규칙이 진행되는데, 참(true)이 아니었다면 이들 하위 규칙은 모두 건너띄어지며(표현이 NULL 값인 경우를 포함하여), 뒤를 잇는 templateElseIf 또는 templateElse 부분이(있는 경우) 대신 고려된다.

<strong>클래스(Class) :</strong> templateElseIf

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : templateCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> templateRule [*]

templateElseIf는 templateIf와 동일한 방법으로 정의된다.

<strong>클래스(Class) :</strong> templateElse

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : templateCondition

<strong>포함(Contains) :</strong> templateRule [*]

<strong>클래스(Class) :</strong> setTemplateValue (templateRule)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

설정될 템플릿 변수

<strong>포함(Contains) :</strong> expression [1]

설정 중인 템플릿 변수의 기본 유형(base-type)과 다중성(cardinality)에 일치하는 유효한 baseType 과 다중성(cardinality)을 갖고 있어야 하는 표현식(expression)이다.

setTemplateValue 규칙에 의하여, 관련 표현(associated expression)을 통해 얻은 값에 템플릿 변수의 값이 설정된다. 템플릿 변수는 이전에 지정된 값을 참조하여 업데이트 될 수 있다. 다시 말해 설정 중인 템플릿 변수는 그 변수가 이전에 지정된 값을 취하는 표현(expression)에 나타날 수 있다.

<strong>클래스(Class) :</strong> setCorrectResponse (templateRule)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

정답값 세트(correct value set)를 갖게 되는 응답 변수(response variable)

<strong>포함(Contains) :</strong> expression [1]

<strong>클래스(Class) :</strong> setDefaultValue (templateRule)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

기본값 세트를 갖게 되는 응답 변수(response variable) 또는 결과 변수

<strong>포함(Contains) :</strong> expression [1]

<strong>클래스(Class) :</strong> exitTemplate (templateRule)

exit template 규칙이 설정되면 템플릿 처리(template processing)는 즉시 종료된다.

</div>
</div>
<!-- chap 10 -->
<div id="chap_11" class="chapter">
<h2><a name="11">11 테스트(Test)</a></h2>
테스트는 assessmentTest 클래스로 표현된다.

<strong>클래스(Class) :</strong> assessmentTest

테스트는 응시자가 어떤 문항을 보는 지, 어떤 순서로, 어떤 방법으로 응시자가 문항과 상호작용 할 것인가를 결정하는 규칙의 연결세트를 갖는 assessmentItem 그룹이다. 이 규칙은 테스트를 통한 유효 경로를 설명하는데, 그 시점은 응답을 응답 처리(response processing)에 제출할 때, 피드백(있다면)이 주어질 때이다.

<strong>속성(Attribute) : </strong>identifier [1]: string

문항의 주식별자(principle identifier). 이 식별자는 테스트의 메타 데이터 내에 상응하는 엔트리를 가지고 있어야 한다. 추가 정보를 위해 메타 데이터와 사용 데이터를 참조

<strong>속성(Attribute) : </strong>title [1]: string

assessmentTest의 타이틀은 테스트가 모든 테스트 세션 외에서 선택될 수 있도록 만들어져 있다. 따라서 전송 엔진은 이 타이틀을 테스트 중에 응시자에게 언제든 보여줄 수 있으나, 의무사항은 아니다.

<strong>속성(Attribute) : </strong>toolName [0..1]: string256

도구 이름 속성은 스스로를 식별하는 테스트를 생성하는 도구를 허용한다. 다른 처리 시스템은 이 정보를 활용 특수 데이터의 콘텐츠로 해석하기 위해 사용할 수 있다. 테스트 루브릭(rubric)의 요소들에 대한 레이블(label) 등을 포함한다.

<strong>속성(Attribute) : </strong>toolVersion [0..1]: string256

저작도구 버전은 도구가 자체 버전을 식별하는 테스트를 만들도록 한다. 이 값은 반드시 toolName 의 문맥(context)에서만 해석되어야 한다.

<strong>포함(Contains) :</strong> outcomeDeclaration [*]

각각의 테스트는 결과의 연결 세트를 갖는다. 이들 결과값들은 테스트의 outcomeProcessing 규칙에 의해 설정된다.

<strong>포함(Contains) :</strong> timeLimits [0..1]

테스트 전체에 대해 응시자에게 허용되는 시간 분량을 선택적으로 제어한다.

<strong>포함(Contains) :</strong> testPart [1..*]

각각의 테스트는 하나 또는 그 이상의 부분으로 나누어 지는데, 이들은 순서대로 섹션, 하위 섹션, 등으로 나뉜다. 하나의 testPart는 테스트의 주요 부분을 나타내며, 그 부분 내에서 모든 섹션과 하위 섹션에 적용되는 기본 모드 파라미터를 통제하기 위해 사용된다.

<strong>포함(Contains) :</strong> outcomeProcessing [0..1]

테스트 결과 값을 계산하기 위해 사용되는 규칙 세트

<strong>포함(Contains) :</strong> testFeedback [*]

테스트 결과에 의해 통제되는 테스트 수준 피드백을 포함한다.
<div id="sec_11.1" class="section">
<h3><a name="11.1">11.1 문항 검색과 정답 제출(Navigation and Submission)</a></h3>
이 표준은 각각의 테스트 부분의 전반적인 행동이 통제될 수 있는 두 가지 방법을 정의한다. 검색 모드와 제출 모드

열거(enumeration) : navigationMode

선형(linear)

비선형(nonlinear)

검색 모드는 응시자가 택할 수 있는 일반적인 경로를 결정한다. 선형(linear) 모드의 testPart는 응시자가 각각의 문항을 차례대로 시도하는 것을 제한한다. 일단 응시자가 옮겨가면, 다시 돌아올 수 없다. 비선형(nonlinear) 모드의 testPart는 이 제한을 제거하며—응시자는 언제든 테스트의 모든 문항을 탐색할 수 있다. 테스트 전송 시스템은, 자체의 사용자 인터페이스 요소를 자유롭게 실행시켜 탐색을 촉진시킬 수 있다.

열거(enumeration) : submissionMode

개별적(individual)

동시적(simultaneous)

제출 모드는 응시자의 응답이 응답 처리 과정에 언제 제출되는가의 여부를 결정한다. 개별 모드(individual mode)의 testPart는 응시자가 응답을 각각의 문항 별로 제출하도록 요구한다. 동시모드(simultaneous mode)에서는 응시자의 응답이 testPart의 종료시 모두 한번에 같이 제출된다.

제출 모드를 선택하면 각 문항 세션(item session)이 테스트 중에 거치는 단계가 결정된다. 동시 모드에서 응답 처리는 testPart가 완료될 때까지 실행되지 않으며, 따라서 각각의 문항 세션(item session)은 interacting과 중단(suspended) 상태 사이에서만 움직인다. 정의상으로 볼때 응시자는 각각의 문항에 대해 오직 한 번의 시도만 할 수 있으며 피드백은 테스트 중간에 보여지지 않는다. 응시자가 자신들이 제출한 정답을 검토할 수 있는 가의 여부 그리고/또는 테스트 이후에 문항 레벨 피드백을 확인할 수 있는 가의 여부는 이 표준의 범위를 벗어나는 내용이다. 동시 모드는 PBT(paper-based test)의 전형적인 양식이다.

개별 모드(individual mode)에서 응답 처리(response processing)는 테스트 중에 실행될 수 있는데 문항 세션(item session)은 Items 에서 설명된 상태를 통과할 수 있는데, 이는 작동 중인 itemSessionControl에 영향을 받는다. 개별(individual) 제출 모드와 비선형(nonlinear) 검색 모드의 공동작동을 지원하는 사용자 인터페이스 시스템을 설계할 때는 주의가 필요하다. 이 시스템에서 응시자는 문항에 대한 자신의 응답을 변경하고 테스트 내의 동일 부분의 다른 문항으로 이동하면서 그 응답을 중지(suspende) 상태로 남겨둘 수도 있다. 테스트 전송 시스템은 테스트 부분 종료 시점에 응답이 제출되지 않은 문항(전통적인 문서 형태의 편집 시스템에서 저장되지 않은 변경사항(unsaved change)과 유사함)이 있음을 응시자에게 분명하게 알려주어야 한다. 테스트 전송 시스템은 보다 적절하다면, 개별(individual) 모드에서 응시자가 다른 문항으로 옮겨가기 이전에 이들 응답을 제출 또는 폐기하도록 요청할 수 있다.

<strong>클래스(Class) :</strong>testPart

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentTest

<strong>속성</strong> :identifier [1]: identifier

테스트 부분 식별자(identifier)는 반드시 테스트 내에서 유일한 것이라야 하며 다른 어떤 assessmentSection 또는 assessmentItemRef의 식별자일 수 없다.

<strong>속성(Attribute) : </strong>navigationMode [1]: navigationMode

<strong>속성(Attribute) : </strong>submissionMode [1]: submissionMode

<strong>포함(Contains) :</strong> preCondition [*]

테스트 중에 평가되는 조건의 선택적 세트로 이 부분이 건너띄어질 것인가를 결정한다.

<strong>포함(Contains) :</strong> branchRule [*]

테스트 중에 평가되는 규칙의 선택적 세트로써, 대체 타겟을 테스트의 다음 부분으로 설정한다.

<strong>포함(Contains) :</strong> itemSessionControl [0..1]

이 부분의 각 문항 세션(item session)에서 허용가능한 상태를 통제하기 위해 사용되는 파라미터. 이들 값은 섹션과 문항 레벨에서 덮어쓰기(override) 될 수 있다.

<strong>포함(Contains) :</strong> timeLimits [0..1]

테스트의 이 부분에서 응시자에게 허용된 시간분량을 선택적으로 통제한다.

<strong>포함(Contains) :</strong> assessmentSection [1..*]

각각의 testPart 에 포함된 문항들은 섹션과 하위 섹션 내에 정렬된다.

<strong>포함(Contains) :</strong> testFeedback [*]

테스트의 이 부분에 특정된 테스트 레벨 피드백

</div>
<div id="sec_11.2" class="section">
<h3><a name="11.2">11.2 테스트 구조(Test Structure)</a></h3>
각각의 테스트 세션에서, 문항과 하위 문항들은 재중의 섹션에서 정의된 규칙에 따라 선택되고 순서대로 정렬된다. 이런 과정의 선택(selection)과 배열(ordering)은 매 세션마다 테스트의 각 부분에 대한 기본 구조를 지정한다. 응시자가 이런 구조를 통해 취할 수 있는 경로들은 그 후 테스트 부분에 대한 모드 세팅에 의해 통제되며, 나아가 테스트 세션 자체 과정 중에서 평가되는 preConditions와 branchRules에 의해서 제어된다.
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_11.1.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-537 size-full" src="{{ "/assets/images/IMS-KR-1002-1_11.1.jpg" | absolute_url }}" alt="IMS KR 1002-1_11.1" width="750" height="496" /></a></div>
<p align="center">그림 11.1 선택(selection) 및 배열(ordering)</p>
이 그림은 테스트의 부분을 나타내며 문항이 섹션과 하위 섹션에서 구성되는 방법을 보여준다.
<div class="pc"><a href="{{ "/assets/images/IMS-KR-1002-1_11.2.jpg" | absolute_url }}" target="_blank"><img class="aligncenter wp-image-538 size-full" src="{{ "/assets/images/IMS-KR-1002-1_11.2.jpg" | absolute_url }}" alt="IMS KR 1002-1_11.2" width="520" height="418" /></a></div>
<p align="center">그림 11.2 선택(selection) 및 배열(ordering)</p>
두 번째 그림은 선택(selection)과 배열(ordering) 규칙을 적용한 이후 동일한 테스트 부분의 특정 인스턴스(instance)를 보여준다. 섹션 S01 규칙은 S01A 과 S01B 중 하나를 선택하며, S02 규칙은 그 규칙에 의해서 포함된 문항들의 순서를 섞고, 최종적으로 S03 규칙은 그 규칙이 포함하고 그 결과를 섞는 3개 문항 중 2개를 선택한다.

<strong>클래스(Class) :</strong> selection

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentSection

선택(selection) 클래스는 각각의 테스트 세션을 위한 섹션의 자식 요소(child elements)를 선택하기위해 사용되는 규칙을 지정한다. 선택규칙이 주어지지 않았다면, 모든 요소들이 선택된 것으로 간주한다.

<strong>속성(Attribute) : </strong>select [1]: integer

선택될 자식 요소(child elements)의 갯수. 하위 섹션은 항상 1로 카운트 되며, 이는 하위 섹션이 얼마나 많은 갯수의 자식 요소를 갖는지 그리고 이들이 보이는 가의 여부와는 무관하다. 선택될 자식(children)의 갯수는 withReplacement이 참(true)인 경우에만 지정된 자식 요소의 갯수를 초과할 수 있다.

<strong>속성(Attribute) : </strong>withReplacement [0..1]: boolean = false

자식 요소(child elements)를 선택할 때, 각각의 요소가 일반적으로 단 한번만 선택 대상의 자격을 갖는다. 다른 말로 하면, {A,B,C,D} 에서 3개의 요소를 선택한다고 할 때, 가능한 결과들는 {A,B,C}, {A,B,D}, {A,C,D}, {B,C,D} 이다, withReplacement를 참(true)으로 설정함으로써, 각각의 요소는 선택대상으로서의 자격을 수 회 가질 수 있다. {A,B,C,D}에서 3개의 노드를 선택하면 {A,A,A}, {A,A,B} 등과 같은 조합결과를 거둘 수 있다.

selection 클래스는 또한 보다 복잡한 선택 알고리즘 지원을 포함해 이 표준까지의 확장을 위한 기회를 제공한다.

<strong>클래스(Class) :</strong> ordering

<strong>관련 클래스(Associated classes)</strong> :assessmentSection

ordering 클래스는 선택(selection) 작업에 이어서, 섹션의 자식 요소(child elements)를 배열하기 위해 사용되는 규칙을 지정한다. 배열(ordering) 규칙이 주어지지 않은 경우, 요소들은 지정된 순서로 정렬되는 것으로 간주한다.

<strong>속성(Attribute) : </strong>shuffle [1]: boolean = false

만약 허용(true)으로 설정된다면, 자식 요소(child elements)의 순서를 무작위로 만든다. 불허(false) 설정이면 자식 요소(child elements)가 지정된 순서를 사용한다.

하위 섹션은 선택을 위해 항상 단일 블럭으로 취급되지만, 이는 셔플링(shuffling)이 가시성에 의존할 때 취급되는 방식이다. 보여지는 하위 섹션은 항상 단일 블럭으로 취급되지만, 보이지 않는 하위 섹션은 그 섹션의 keepTogether 속성이 true인 경우에만 단일 블럭으로 취급된다. 그렇지 않다면, 보이지 않는 하위 섹션의 자식 요소(child elements)는 셔플링(shuffling)에 앞서 부모의 선택(parent’s slection)으로 혼합된다.

ordering 클래스는 또한 보다 복잡한 배열(ordering) 알고리즘 지원을 포함해 이 표준까지의 확장을 위한 기회를 제공한다.

선택(selection)과 배열(ordering) 규칙은 테스트 각 인스턴스(instance)에 해당하는 문항의 시퀀스를 지정한다. 시퀀스는 첫 번째 테스트 부분의 첫 번째 섹션의 첫 번째 문항과 함께 시작하며, 마지막 테스트 부분의 마직막 섹션의 마지막 문항까지 계속된다. 이 시퀀스는 테스트 내내 일관된다. 일반적으로 이것은 응시자가 인식한 논리적 시퀀스이지만, preConditions 또는 branchRules 의 사용은 선택된 특정 경로에 영향을 미친다.

교체(replacement)가 가능한 선택(selection)을 사용하면 동일한 assessmentItemRef가 언급한 한 문항의 두개 또는 그 이상의 인스턴스(instance)를 작동시켜 테스트의 문항 시퀀스에 나타나게 한다. 그러므로 그 문항을 branchRule의 타겟으로 정하는 건 오류이다. 나아가 테스트 결과를 보고할 때, 각 문항의 시퀀스 번호는 반드시 모호성을 피하여 보고되어야 한다. 결과 보고(Results Reporting) 참조

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>sectionPart

<strong>파생 </strong><strong>클래스(Derived classes)</strong> : assessmentItemRef, assessmentSection, include

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: assessmentSection

개별 문항 참조(reference) 또는 하위 섹션과 함께 묶인 섹션들. 공통 파라미터 숫자는 자식 요소(child element)의 두 가지 유형이 공유한다.

<strong>속성(Attribute) : </strong>identifier [1]: identifier

섹션 또는 문항 참조(reference) 식별자(identifier)는 반드시 테스트 내에서 유일한 것이라야 하며 다른 어떤 testPart의 식별자일 수 없다.

<strong>속성(Attribute) : </strong>required [0..1]: boolean = false

만약 자식 요소(child element)가 요구된다면, 이 요소는 반드시 (적어도 한번은) 선택(selection)에 나타나야 한다. 만약 섹션이 필수 요소의 갯수 보다 적은 수의 자식 요소를 택하는 선택 규칙을 포함한다면 이것은 에러이다.

<strong>속성(Attribute) : </strong>fixed [0..1]: boolean = false

자식 요소(child element)가 고정(fixed)이면, 이 요소는 셔플(shuffle) 될 수 없다. 선택 규칙과 함께 사용될 때, 고정 요소는 선택이 실행될 때까지 자체의 위치를 고정할 수 없다. 예를 들어, 교체없이 {A,B,C,D} 중 3개의 요소를 선택하면 {A,B,C} 결과를 얻을 수 있다. 만약 섹션이 셔플링에 영향을 받을 수 있어도 B가 고정되어 있다면, {A,C,B}와 같은 치환(permutations)은 허용되지 않는 반면, {C,B,A}와 같은 치환은 허용된다.

<strong>포함(Contains) :</strong> preCondition [*]

테스트 중에 평가되는 조건의 선택적 세트로, 문항 또는 섹션이 건너 띄어질 수 있는 지를 결정한다. (비선형(nonlinear) 모드에서 사전조건(pre-conditions )은 무시된다.)

<strong>포함(Contains) :</strong> branchRule [*]

테스트 중에 평가되는 규칙의 선택적 세트로, 대체 타겟을 다음 문항 또는 섹션으로 설정하기 위한 것이다. (비선형(nonlinear) 모드에서 branch 규칙은 무시된다.)

<strong>포함(Contains) :</strong> itemSessionControl [0..1]

각 문항 세션(item session)에서 허용 가능한 상태를 통제하기 위해 사용되는 파라미터(하위 섹션 또는 문항 레벨에서 덮어쓰기(override)가 가능하다)

<strong>포함(Contains) :</strong> timeLimits [0..1]

이 문항 또는 섹션에 대해 응시자에게 허용되는 시간분량을 선택적으로 제어한다.

<strong>클래스(Class) :</strong> assessmentSection (sectionPart)

관련 클래스(Associated classes) :

testPart

<strong>속성(Attribute) : </strong>title [1]: string

섹션의 타이들은 섹션 콘테츠가 없는 상황에서 그 섹션이 선택될 수 있도록 만들어져 있다. 이 상황이란 예를 들어 응시자가 테스트를 검색하고 있는 상황이다. 따라서 전송 엔진은 이 타이틀을 테스트 중에 응시자에게 언제든 보여줄 수 있으나, 의무사항은 아니다.

<strong>속성(Attribute) : </strong>visible [1]: boolean

응시자가 식별가능한 가기성 섹션(visible section)이다. 예를 들어, 전송 엔진은 테스트에 계층적(hierarchical) view를 제공하여 검색을 도울 수 있다. 이러한 view에서는 비저블 섹션이 계층(hierarchy) 내의 가시성 노드가 될 것이다. 반대로 말해, 비가시성 섹션은 응시자에게 보이지 않는 다는 것이다—비가시성 섹션의 자식 요소(child element)는 부모(parent) 섹션(또는 <a href="#em_5">testPart</a>)의 일부인 것처럼 응시자에게 보여질 수 있다. 섹션의 가시성은 섹션의 자식 요소의 가시성에는 영향을 미치지 않는다. 각 섹션의 가시성은 오직 그 섹션 자체의 visible 속성에 의해 결정된다.

<strong>속성(Attribute) : </strong>keepTogether [0..1]: boolean = true

셔플링(shuffling)되기 쉬운 부모(parent)를 갖는 인비저블 섹션(invisible section)은 자식들, 응시자에게는 부모의 일부인 것처럼 보이게 될 이 자식들이 블럭으로 셔플될 것인지 또는 부모 섹션의 다른 자식들과 함께 섞일 것인 지를 결정한다.

<strong>포함(Contains) :</strong> selection [0..1]

섹션의 어떤 자식들(children)이 테스트의 각 인스턴스(instance)에 사용될 것인가를 선택하기 위해 사용되는 규칙들

<strong>포함(Contains) :</strong> ordering [0..1]

섹션의 어떤 자식들이 테스트의 각 인스턴스를 위해 어떤 순서로 정렬될 것인가를 결정하기 위해 사용되는 규칙들

각각의 섹션은 자체의 선택(selection)과 배열(ordering) 규칙을 갖고 있으며 섹션의 부모에 앞서 나타난다. 자식 섹션(child section)은 자체의 자식들의 순서를 셔플할 수도 있으며, 동시에 여전히 부모 섹션(parent section)을 셔플링할 때 이들 자식들을 함께 두도록 요청할 수 있다.

<strong>포함(Contains) :</strong> rubricBlock [*]

섹션 루브릭(section rubric)은 각 문항이 포함된(직접적으로 또는 간접적으로) 채 섹션에 의해 응시자에게 제시된다. 섹션은 중첩이 가능하기 때무에, 각 문항을 위해 제시된 루브릭은 탑 모스트(top-most) 섹션부터 문항의 즉각적으로 인클로징되는 섹션까지의 루브릭 블럭의 연속인 것이다.

<strong>포함(Contains) :</strong> sectionPart [*]

빈 섹션(empty section)은 선택(selection) 확장 매커니즘을 사용해 그 콘텐츠를 설명하는 섹션으로 간주된다.

<strong>클래스(Class) :</strong> assessmentItemRef (sectionPart)

문항은 직접적인 집합에 의해서가 아닌 참조(reference)에 의해서 테스트 안으로 통합된다. 그 참조의 식별자(identifier)가 이 테스트 밖의 다른 어떤 의미를 가질 필요가 없음을 명심한다. 특히, 다른 어떤 카탈로그의 콘텍스트 안에서 유일할 필요가 없으며 문항의 메타 데이터 안에 표시될 필요도 없다. 이 식별자의 형식(syntax)은 assessmentItem 자체의 식별자(identifier) 속성의 신텍스보다 제한적이다.

<strong>속성(Attribute) : </strong>href [1]: uri

문항의 파일(즉, 동일한 콘텐츠 패키지 안의 다른 곳)을 참조하기 위해 사용되는 uri. 이것이 유일해야 할 의무는 없다. 테스트는 동일한 문항을 테스트 내에서 여러 번 참조될 수 있다. 하지만 각각의 참조는 반드시 유일한 식별자(identifier)를 가져야 함에 유의한다.

<strong>속성(Attribute) : </strong>category [*]: identifier

문항들을 하나 또는 그 이상의 카테고리에 선택적으로 지정될 수 있다. 카테고리들은 결과 처리 과정에서 문항 결과의 맞춤(custom) 세트가 모아지도록 허용하는 일에 사용된다.

<strong>포함(Contains) :</strong> variableMapping [*]

변수 매핑(mapping)들은 이 테스트의 목적을 위한 문항 결과의 이름을 변경하기 위해 사용된다.

<strong>포함(Contains) :</strong> weight [*]

weights는 맞춤(custom) 값이 문항의 결과를 측정하기 위해 지정되도록 한다.

<strong>포함(Contains) :</strong> templateDefault [*]

템플릿 기본값은 테스트 레벨에서 평가된 표현(espression)을 기초로 한 문항에 의해 선언되는 템플릿 변수의 기본값을 변경하기 위해 사용된다. 추가 정보는 templateDefault 참조

<strong>클래스(Class) :</strong> weight

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: assessmentItemRef

개별 문항 점수가 전반적인 테스트 점수에 기여하는 바는 대개 테스트에 따라 다르게 나타난다. 문항의 점수는 'weighted' 되었다고 말한다. weights는 테스트 내의 문항(assessmentItemRef)에 대한 각각의 참조(reference)의 일부로 지정된다.

<strong>속성(Attribute) : </strong>identifier [1]: identifier

하나의 문항은 몇 개의 weights라도 가질 수 있으며, 각각의 웨이트에는 결과 처리 안의 웨이트를 참조하기 위해 사용되는 식별자(identifier)를 부여 받는다. (변수와 testVariables 참조)

<strong>속성(Attribute) : </strong>value [1]: float

weights는 부동 소수점(floating point) 값이다. 웨이트는 기본형 플로트(float) 또는 정수(integer) 기본형 결과 변수에 적용될 수 있다. 웨이트는 변수값이 결과 처리 중에 평가되는 시점에 적용된다. 그 결과는 항상 기본형 플로트를 갖는 것으로 처리되는데, 이는 변수 자체가 기본형 정수로 선언되었어도 마찬가지이다.

<strong>클래스(Class) :</strong> variableMapping

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentItemRef

변수 매핑은 해당 문항 안의 sourceIdentifier 이름과 함께 선언되는 결과 변수들이 마치 outcomeProcessing 중에 targetIdentifier 이름과 함께 선언된 것처럼 취급되도록 허용한다.

<strong>속성(Attribute) : </strong>sourceIdentifier [1]: identifier

<strong>속성(Attribute) : </strong>targetIdentifier [1]: identifier

<strong>클래스(Class) :</strong> templateDefault

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: assessmentItemRef

문항 안의 템플릿 변수 기본값은 템플릿이 예시된 테스트 콘텍스트를 기초로 덮어쓰기(override) 될 수 있다. 그 값은 테스트 레벨의 문항에 대한 참조(reference) 내에서 정의된 표현식(expression)을 평가함으로써 도출되며, 이는 테스트 내의 다른 문항에서 또는 테스트 레벨 자체에서 정의된 결과에서 취해진 변수값에 의존하게 될 수 있다.

지속적인 결과를 위해, 표현식(expression)의 시기적절한 평가가 매우 중요하다. assessmentItemRef가 선형(linear) 모드에서 검색되는 testPart에서 발생할 때, 표현은 첫 번째 시도 시작 이전에, 다른 사전조건(pre-condition)이 평가되고 발동된 후에, 하지만 문항 자체의 templateProcessing 규칙이 이어 따라오기 전에, 즉시 평가된다. 비선형(nonlinear) 모드에서 표현은 testPart의 시작 시에 평가된다. 두 경우 모두, 타이밍은 사실상 submissionMode에 영향을 받지 않는다. 응답 변수(response variable) 값이 제출되기 전에 사용되지 않도록, 결과 변수들이 그 값이 해당 응답 또는 결과 처리 단계에 의해 설정되기 전에 사용되지 않도록 보장하기 위해 각별한 주의가 필요하다.

<strong>속성(Attribute) : </strong>templateIdentifier [1]: identifier

영향을 받는 템플릿 변수의 식별자(identifier)

<strong>포함(Contains) :</strong> expression [1]

연결변수의 templateDeclaration 선언과 매칭되는 baseType과 다중성(cardinality)을 갖는 값을 결과로 거두어야 하는 표현

템플릿 덮어쓰기(override) 기본값의 기능은 문항 템플릿이 테스트 내의 다른 문항(또는 템플릿)에 링크되도록 하는 것이다. 한 문항에서의 응시자 응답은 직접적으로 사용되어 표현(presentation) 또는 이후에 제시되는 문항의 행동에 영향을 미칠 수 있다. 하지만 템플릿이 일단 예시되면 템플릿은 독립적으로 작동한다—문항들 사이에서 생성된 다이내믹 링크는 존재하지 않으며, 이들 간에 공유된 변수 공간(variable space)에 대한 개념도 존재하지 않는다.

</div>
<div id="sec_11.3" class="section">
<h3><a name="11.3">11.3 시간 제한(Time Limits)</a></h3>
<strong>클래스(Class) :</strong> timeLimits

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentTest, testPart, sectionPart

<strong>속성(Attribute) : </strong>minTime [0..1]: duration

<strong>속성(Attribute) : </strong>maxTime [0..1]: duration

특정 assessmentTest의 문맥(context) 안에서, 문항, 또는 문항의 그룹은 시간 제한의 영향을 받을 수 있다. 이 표준은 시간 제한의 최소치와 최대치를 모두 지원한다. 단일 문항을 위해 통제된 시간은, 내장형(built-in)응답 변수(response variable) duration에 의해 지정된 대로, 단순한 문항 세션(item session)의 duration이다. assessmentSections의 경우, 시간 제한(time limits)은 testParts와 전체 assessmentTests을 모든 문항 세션(item session)과 테스트의 그부분을 검색하는 데 소요되는 다른 시간을 더한 duration에 연결한다. 다른 말로, 그 시간은 문항이 상호작용하지 않는 단계, 검색(navigation) 스크린에 소요되는 시간 등을 포함한다는 것이다.

선형(linear) 검색 모드가 활동하고 있을 시에만 assessmentSections와 assessmentItems에 최소치 시간이 적용된다.

전송 엔진은 시간 제한이 적용 중일 때 각각의 테스트 부분에 소용된 시간을 추적하고 보고하도록 요구된다. 만약 주어진 테스트 부분 또는 섹션에 시간 제한이 작동 중이지 않다면, 그 시간을 추적하고 보고할 수는 있으나 이는 의무사항이 아니다. 마찬가지로 만약 시간제한 문항(Time Dependent Item)이 아닌 문항에 시간 제한이 작동 중이지 않다면, 이때 소요되는 시간은 보고될 수는 있으나 역시 의무사항이 아니다.

테스트에 소요된 시간은, 그 시간이 테스트 레벨에 선언된 duration으로 불리는 내장된(built-in)응답 변수(response variable)인 것처럼, 그리고 기본 유형(base-type) duration 과 단일 다중성(single cardinality)인 것처럼, 기록된다. 마찬가지로 테스트 부분 또는 섹션에 소요된 시간은 각각의 개별 범위 내에서 선언된 내장된(built-in) 응답 변수(response variable)처럼 취급된다. 이들 durations 값은 마침표가 붙는 부분 또는 섹션의 식별자와 함께, 앞서 지정된 변수 이름 duration을 사용함으로써 outcomeProcessing 중에 참조될 수 있다.

</div>
</div>
<!-- chap 11 -->
<div id="chap_12" class="chapter">
<h2><a name="12">12 결과 처리(Outcome Processing)</a></h2>
<strong>클래스(Class) :</strong> outcomeProcessing

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentTest

결과 처리는 응시자가 문항에 (개별(individual) 제출 모드일 때) 또는 문항 그룹에(동시(simultaneous) 대한 응답을 제시할 때마다 작동한다. 이 작동은 응답제출에 의해 모든(문항 레벨) 응답 처리가 작동된 후에 일어난다. 테스트의 결과 변수 값은 outcomeRules이 설명하는 지시사항을 실행하기에 앞서 항상 기본값으로 재설정된다. 결과 처리가 응시자가 응답을 제출할 때마다 작동하기 때문에, test-level 결과의 결과값은 테스트 중에 test-level 피드백을 활성화시키기 위해 또는 preConditions와 branchRules를 사용함으로써 이후 부분의 행동을 제어하기 위해 사용될 수 있다.

결과 처리 구조는 responseProcessing의 구조와 유사하다.

<strong>포함(Contains) :</strong> outcomeRule [*]

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>outcomeRule

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :exitTest, include, lookupOutcomeValue, outcomeCondition, outcomeProcessingFragment, setOutcomeValue

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :outcomeIf, outcomeElse, outcomeProcessingFragment, outcomeProcessing, outcomeElseIf

<strong>클래스(Class) :</strong> outcomeCondition (outcomeRule)

<strong>포함(Contains) :</strong> outcomeIf [1]

<strong>포함(Contains) :</strong> outcomeElseIf [*]

<strong>포함(Contains) :</strong> outcomeElse [0..1]

만약 outcomeIf 또는 outcomeElseIf에서 주어진 표현이 참(true)으로 평가되면, 그 안에 포함된 하위 규칙들이 이어서 따라오며, 이하의 모든 outcomeElseIf 또는 outcomeElse 부분들은 이번 결과 조건(outcome condition)에서는 무시된다.

만약 outcomeIf 또는 outcomeElseIf에서 주어진 표현이 참(true)으로 평가되지 않으면, 고려사항은 다음 outcomeElseIf로 진행되거나, 또는 만약 더 이상의 outcomeElseIf 부분이 없다면, outcomeElse의 하위 규칙들이 뒤를 잇는다(지정된 경우).

<strong>클래스(Class) :</strong>outcomeIf

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : outcomeCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> outcomeRule [*]

outcomeIf 부분은 표현식(expression)으로 이루어 지는데, 이 표현은 반드시 유효한 baseType으로 된 논리(boolean) 및 단일 다중성(single cardinality)을 갖추어야 한다. 적용된 런타임 데이터 모델에 관한 정보는 표현(expressions)을 참조한다. 이 부분은 또한 하위 규칙 세트를 포함한다. 만약 표현이 참(true)인 경우, 하위 규칙이 진행되는데, 참(true)이 아니었다면 이들 하위 규칙은 모두 건너띄어지며(표현이 NULL 값인 경우를 포함하여), 뒤를 잇는 outcomeElseIf 또는 outcomeElse 부분이(있는 경우) 대신 고려된다.

<strong>클래스(Class) :</strong> outcomeElseIf

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : outcomeCondition

<strong>포함(Contains) :</strong> expression [1]

<strong>포함(Contains) :</strong> outcomeRule [*]

outcomeElseIf는 outcomeIf와 동일한 방법으로 정의된다.

<strong>클래스(Class) :</strong> outcomeElse

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: outcomeCondition

<strong>포함(Contains) :</strong> outcomeRule [*]

<strong>클래스(Class) :</strong> exitTest (outcomeRule)

</div>
<!-- chap 12 -->
<div id="chap_13" class="chapter">
<h2><a name="13">13 테스트 레벨 피드백(Test-level Feedback)</a></h2>
<strong>클래스(Class) :</strong> testFeedback

<strong>관련 </strong><strong>클래스(Associated classes)</strong> : assessmentTest, testPart

<strong>속성(Attribute) : </strong>access [1]: testFeedbackAccess

테스트 피드백은 결과처리(테스트 중에) 다음에 응시자에게 직접적으로 보여지거나, 또는 적절한 경우(atEnd로 불림) testPart 또는 assessmentTest의 종료 시점에 보여진다.

결과 변수 값은 showHide와 식별자(identifier) 속성과 함께 사용되어 피드백이 실제로 feedbackElement에 대한 것과 유사한 방법으로 보여질 것인가를 결정한다.

<strong>속성(Attribute) : </strong>outcomeIdentifier [1]: identifier

<strong>속성(Attribute) : </strong>showHide [1]: showHide

<strong>속성(Attribute) : </strong>identifier [1]: identifier

<strong>속성(Attribute) : </strong>title [0..1]: string

전송 엔진은 응시자에게 타이틀을 반드시 보여줄 의무는 없으나, 보여줄 수도 있다. 팝업 윈도우의 타이틀 또는 연결 보고(combined report)의 하위 머릿말(heading)이 그 예이다.

<strong>포함(Contains) :</strong> flowStatic [*]

testFeedback의 콘텐츠는 어떠한 interaction도 포함할 수 없다.

열거(ㄷnumeration) : testFeedbackAccess

atEnd

during

</div>
<!-- chap 13 -->
<div id="chap_14" class="chapter">
<h2><a name="14">14 사전조건과 분기(Pre-conditions and Branching)</a></h2>
사전조건과 분기 규칙은 적응성 요소를 assessmentTest 표준에 도입하기 위해 사용되는 진보된 개념이다. 이 개념은 버전 1.2에서(사전조건과 사후조건으로) 도입되었으나 이들 표준은 버전 2.1까지 연기되었다. 이들 특성(features)의 도입에 있어서 주요 고려대상이었던 점은 일부 문항(또는 섹션과 테스트 부분 전체)을 테스트 초반에 제시되었던 문항에 대한 응시자의 응답에 따라 건너띄도록 하면서, 전송 엔진을 지원하는 복합성을 제한하는 것이었다.

사전조건과 분기 규칙은 선형(linear) 모드에서 검색되는 테스트 부분에만 적용된다. 비선형(nonlinear) 모드에서 이들은 무시된다. 지배적인 테스트 부분(overarching test parts)는 비선형 모드에서 효과적으로 검색되며 따라서 연결 사전조건과 분기 규칙을 가질 수 있다.

<strong>클래스(Class) :</strong> preCondition

<strong>관련 </strong><strong>클래스(Associated classes) </strong>:testPart, sectionPart

preCondition은 만약 문항이 제시되는 경우 참(true)으로 평가되어야 하는 assessmentSection 또는 assessmentItemRef에 첨부된 단순 표현식(expression)이다. 사전조건들은 연결 문항, 섹션, 또는 testPart가 응시자에 의해 테스트 중에 시도되려 할 때 평가된다. 이들은 선택(selection)과 배열(ordering)(테스트 구조 참조)을 위한 규칙과 구별되는데, 이들은 테스트의 시작 시에 또는 전에 따라온다.

표현식(expression)이 불허(false)로 평가되거나 NULL 값을 가진다면, 그 연결 문항 또는 섹션은 건너띄어 진다.

<strong>포함(Contains) :</strong> expression [1]

<strong>클래스(Class) :</strong> branchRule

<strong>관련 </strong><strong>클래스(Associated classes) </strong>: testPart, sectionPart

분기 규칙(branch-rule)은 그 문항, 섹션, 또는 부분이 응시자에게 제시된 이후에 평가되는 assessmentItemRef, assessmentSection 또는 testPart에 첨부된 단순 표현식(expression)이다. 만약 표현이 참(ture)으로 평가되면, 그 테스트는 타겟 식별자가 참조하는 문항, 섹션 또는 부분으로 점프 포워드(jump forward)한다. 문항 또는 섹션의 경우에, 타겟은 반드시 아직 제시되지 않은 동일한 testPart 안의 문항 또는 섹션을 참조해야 한다. testParts의 경우, 타겟은 반드시 다른 testPart를 참조해야 한다.

<strong>[</strong><strong>코멘트]</strong> 상기 정의는 선형(linear) 테스트 부분을 통해 트리가 되는 검색 경로를 제한한다. 다른 말로, 순환(cycle)이 허용되지 않는다. 대부분의 경우, 특정 결과가 달성될 때(또는 만약) 그 섹션을 조기에 종료하는 preCondition 또는 branchRule과 공동으로 withReplacement을 적절한 반복의 상한(upper bound)까지 선택하는 섹션을 사용함으로써, 반복이 가능하다. (이 기술(technique)을 하나 또는 그 이상의 Item Templates과 함께 사용하여 예를 들어 반복 연습(drill and practice)을 얻어낼 수 있다.) 그러나, unbounded 반복은 지원되지 않는다. 이러한 접근이 너무 제한적인가에 대한 코멘트를 구한다.

<strong>속성(Attribute) : </strong>target [1]: identifier

다음 값들은 확보되어 있는 것들이며 타겟 식별자로 사용될 때 특수한 의미를 갖는다: EXIT_SECTION은 바로 뒤를 잇는 문항에 대한 현재 섹션의 남은 자식(children) 모두를 뛰어 넘는다; EXIT_TESTPART는 현재의 testPart를 즉시 종료하고 EXIT_TEST는 전체 assessmentTest를 즉시 종료한다.

<strong>포함(Contains) :</strong> expression [1]

</div>
<!-- chap 14 -->
<div id="chap_15" class="chapter">
<h2><a name="15">15 표현(Expressions)</a></h2>
<strong>추상 </strong><strong>클래스(Abstract class) :</strong>expression

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :

and, anyN, baseValue, containerSize, contains, correct, customOperator, default, delete, divide, durationGTE, durationLT, equal, equalRounded, fieldValue, gt, gte, index, inside, integerDivide, integerModulus, integerToFloat, isNull, lt, lte, mapResponse, mapResponsePoint, match, member, multiple, not, null, numberCorrect, numberIncorrect, numberPresented, numberResponded, numberSelected, or, ordered, outcomeMaximum, outcomeMinimum, patternMatch, power, product, random, randomFloat, randomInteger, round, stringMatch, substring, subtract, sum, testVariables, truncate, variable

<strong>관련 </strong><strong>클래스(Associated classes)</strong> :

and, gt, ordered, divide, setCorrectResponse, random, responseIf, substring, member, equalRounded, outcomeIf, integerToFloat, lookupOutcomeValue, setTemplateValue, integerDivide, gte, index, durationLT, contains, durationGTE, branchRule, lt, match, patternMatch, product, multiple, power, outcomeElseIf, setDefaultValue, customOperator, stringMatch, setOutcomeValue, templateDefault, not, templateElseIf, integerModulus, subtract, responseElseIf, anyN, preCondition, round, containerSize, inside, equal, or, isNull, templateIf, lte, sum, truncate, fieldValue, delete

표현(expressions)은 값을 문항 변수(item variable)에 지정하기 위해서 사용되며 응답 및 템플릿 처리에서 조건적 행동(conditional actions)을 제어하기 위해 사용된다.

표현은 itemVariable의 값이거나, baseTypes이 지정하는 값 세트 중 하나에서 도출된 상수값(constant value), 또는 계층적(hierarchical) 표현 operator에 대한 단순 참조일 수 있다. itemVariables 처럼, 각각의 표현은 또한 특수값 NULL을 가질 수 있다.
<div id="sec_15.1" class="section">
<h3><a name="15.1">15.1 내장형(built-in)의 일반적 표현</a></h3>
이 절에서는 상수들, 무작위 값, itemVariables 값, 그리고 다음 클래스들을 다루기 위한 다수의 내장형(built-in) 일반적 표현을 설명한다.

<strong>클래스(Class) :</strong> baseValue (expression)

<strong>속성(Attribute) : </strong>baseType [1]: baseType

값의 기본 유형(base-type)

가장 단순한 표현식(expression)은 주어진 baseType이 지정하는 세트에서 도출된 단일(single)값을 반환한다.

<strong>클래스(Class) :</strong> variable (expression)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

이 표현식(expression)은, 해당 variableDeclaration에서 선언되었거나 내장형(built-in) 변수 중의 하나인 itemVariable의 값을 찾는다. 결과는 기본 유형(base-type)을 가지며, 가중치 결과(weighted outcomes)의 형 확장(type promotion)에 영향을 받기 쉬운 변수를 위해 선언된 다중성(cardinality)을 갖는다. (아래 참조)

결과 처리 과정 중에, 개별 문항 세션(item session)에서 도출된 값은, 지정된 식별자와 함께 문항 변수(item variable)의 이름을 assessmentItemRef 안의 문항 앞에 붙임으로써 찾아지며, 이들은 마침표로 분리된다. 예를 들어, Q01로 불리는 문항 내의 SCORE 변수값을 도출하기 위해서는 식별자 Q01.SCORE를 갖는 변수 인스턴스를 사용해야 할 것이다.

응답 변수(response variable) 값을 찾을 때는, 항상 응시자의 마지막 제출에 의해 그 변수에 지정된 값이 필요하다. 제출되지 않은 응답은 표현식(expression) 중에는 이용할 수 없다.

동일한 assessmentItemRef (선택(selsection) withReplacement 를 사용하여)로부터 여러 번 예시된 문항에서 얻은 문항 변수(item variable) 값은, 만약 제출이 동시(simultaneous) 모드라면 마지막 인스턴스에서 도출된 것이며, 그렇지 않다면 그 값은 미지정된 것이다.

<strong>속성(Attribute) : </strong>weightIdentifier [0..1]: identifier

변수 값에 적용될 선택적인 가중치(weighting)이다. 가중치(weights)는 테스트 콘텍스트(test context)에서만 지정되며(따라서 오직 결과 처리에서만), 이는 오직 문항 식별자를 붙이는 기술(아래 참조)이 문항 변수(item variable)값을 찾기위해 사용될 때만이다. 가중치 식별자는 해당 assessmentItemRef 안의 가중치 정의를 참조한다. 일치하는 정의를 찾을 수 없는 경우, 가중치는 1.0으로 간주한다.

가중치는 기본형 정수(integer)와 플로트(float)를 갖는 문항 변수(item variable)에만 적용된다. 만약 문항 변수(item variable)가 다른 유형일 경우, 가중치는 무시된다. 모든 웨이트는 기본형 플로트(float)를 갖는 것으로 처리되며 그 결과값은 그 변수 값에 연결 가중치를 곱하여 얻는다. 가중치를 기본형 정수를 갖는 변수값에 적용시킬 때, 이 변수는 형 확장(type promotion)에 영향을 받으며 그 표현의 결과는 기본형 플로트를 갖는다.

<strong>클래스(Class) :</strong> default (expression)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

이 표현은 itemVariable 선언을 찾고, 기본 값이 선언되지 않은 경우 연결 defaultValue 또는 NULL 을 반환한다. 결과처리에 사용되는 경우, 문항 식별자 붙이기(변수 참조)가 개별 문항에서 기본값을 얻기 위해 사용될 수 있다.

<strong>클래스(Class)</strong> : correct (expression)

<strong>속성(Attribute)</strong> : identifier [1]: identifier

이 표현은 응답 변수(response variable) 선언을 찾고, 기본 값이 선언되지 않은 경우 연결 correctResponse 또는 NULL을 반환한다. 결과처리에 사용되는 경우, 문항 식별자 붙이기(변수 참조)가 개별 문항에서 기본값을 얻기 위해 사용될 수 있다.

<strong>클래스(Class) :<a id="element10578"></a></strong> mapResponse (expression)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

이 표현은 응답 변수(response variable) 값을 찾고 난뒤 연결 매핑을 사용하여 그 변수를 변환하는데, 이는 반드시 선언되었어야 한다. 결과는 단일 플로트(float)이다. 응답 변수(response variable)가 단일 다중성(single cardinality)을 갖는 다면, 반환값은 맵에서 도출된 단순한 매핑 타겟 값이다. 응답 변수(response variable)가 다중(multiple) 또는 순차적 다중성(ordered cardinality)을 갖는 다면, 반환값은 매핑된 타겟 값의 합이 된다. 이 표현은 레코드 다중성(record cardinality) 변수에는 적용될 수 없다.

예를 들어, 매핑이 식별자{A,B,C,D}와 값{0,1,0.5,0}을 각각 연결할 때, mapResponse는 단일 값 'C' 를 숫자 값 0.5에 매핑하고 값 세트{C,B}을 값1.5에 매핑할 것이다.

만약 컨테이너가 동일 값의 인스턴스를 다수 갖는다면, 그 값은 단 한번만 카운트 된다. 위의 예를 계속하면 {B,B,C}는 2.5가 아닌 1.5에 매핑되는 것이다.

<strong>클래스(Class) :</strong> mapResponsePoint (expression)

<strong>속성(Attribute) : </strong>identifier [1]: identifier

이 표현은 기본 유형(base-type)이 포인트(point)이어야 하는 응답 변수(response variable) 값을 찾아서 연결areaMapping을 이용해 그 값을 변환한다. 이 변환은 mapResponse와 유사하지만, 포인트가 각각의 영역에서 차례대로 테스트 된다는 점이 예외이다. 컨테이너를 매핑할 때, 각각의 영역은 단 한번만 매핑될 수 있다. 예를 들어, 응시자가 동일 영역에 해당하는 두 개의 포인트를 파악했다면, mappedValue은 그래도 계산된 총합에 한 번만 추가된다.

<strong>클래스(Class) :</strong> null (expression)

null은 NULL값을 반환하는 단순 표현이다—null 값은 다른 어떤 원하는 baseType인 것처럼 취급된다.

<strong>클래스(Class) :</strong> randomInteger (expression)

일부 정수 n을 위한 min + step * 을 만족하는 지정된 범위 [min,max]에서 무작위 정수를 선택한다. 예를 들어, min=2, min=2, max=11, step=3 으로는, 값 {2,5,8,11}이 가능하다.

<strong>속성(Attribute) : </strong>min [1]: integerOrTemplateRef = 0

<strong>속성(Attribute) : </strong>max [1]: integerOrTemplateRef

<strong>속성(Attribute) : </strong>step [0..1]: integerOrTemplateRef = 1

<strong>클래스(Class) :</strong> randomFloat (expression)

지정된 범위[min,max]에서 무작위 플로트(float)를 선택한다.

<strong>속성(Attribute) : </strong>min [1]: floatOrTemplateRef = 0

<strong>속성(Attribute) : </strong>max [1]: floatOrTemplateRef

</div>
<div id="sec_15.2" class="section">
<h3><a name="15.2">15.2 결과 처리에만 사용된 표현</a></h3>
이 섹션은 outcomeProcessing 에서만 사용될 수 있는 다수의 내장형(built-in) 표현을 설명한다. 이 표현들은 assessmentTest 에서 참조된 문항 세트에 대한 정보를 반환한다.

<strong>추상 </strong><strong>클래스(Abstract class) :</strong>itemSubset

<strong>파생 </strong><strong>클래스(Derived classes)</strong> :

numberCorrect, numberIncorrect, numberPresented, numberResponded, numberSelected, outcomeMaximum, outcomeMinimum, testVariables

이 클래스는 assessmentTest에서 선택된 문항의 하위 세트에 대한 개념을 정의한다. 이 속성들은 하위 세트의 모든 멤버에 의해 일치되어야 하는 기준을 정의한다. 이는 테스트 전체에 대한 또는 그 테스트의 임의적 하위세트에 대한 정보를 반환하기 위한 outcomeProcessing내의 여러 표현들을 제어하기 위해 사용된다.

<strong>속성(Attribute) : </strong>sectionIdentifier [0..1]: identifier

지정되었다면, 오직 매칭 식별자를 갖는 assessmentSection의 문항에서 도출된 변수만이 매칭된다. 하위 섹션에 있는 문항은 이 정의에 포함된다.

<strong>속성(Attribute) : </strong>includeCategory [*]: identifier

지정되었다면, 매칭 범주(category)를 갖는 문항에서 도출된 변수만이 포함된다.

<strong>속성(Attribute) : </strong>excludeCategory [*]: identifier

지정되었다면, 매칭 범주(category)를 갖지 않는 문항에서 도출된 변수 만이 포함된다.

<strong>클래스(Class) :</strong> testVariables (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 이와 동시에 테스트에 참조된 문항의 하위 세트의 itemVariable 값을 찾는다. 단일 다중성(single cardinality)를 갖는 변수 만이 고려대상이 되며, 모든 NULL 값은 무시된다. 결과는 아래 지정된 것처럼 중복 다중성(cardinality multiple)과 기본 유형(base-type)을 갖는다.

<strong>속성(Attribute) : </strong>variableIdentifier [1]: identifier

각 문항에서 찾을 변수 식별자. 만약 테스트가 다른 변수 네이밍 규칙(naming conventions)들을 합하는 경우, variableMappings이 결과 처리의 복잡성을 낮추고 단일 testVariables 표현의 사용을 허용하는 데 이용될 수 있다. 매칭 변수를 갖지 않는 문항은 무시된다.

<strong>속성(Attribute) : </strong>baseType [0..1]: baseType

지정된 경우 이 baseType과 함께 선언된 변수에만 부합한다. 이는 또한 결과의 기본 유형(base-type)이 된다. (아래 설명처럼 웨이팅을 통한 형 확장(type promotion)에 영향을 받는다). 생략되었다면, 기본 유형(base-type) 정수(integer) 또는 플로트(float)와 함께 선언된 변수들만이 부합된다. 모든 매칭값이 기본 유형(base-type) 정수를 갖는 경우, 결과의 기본 유형은 정수며, 그렇지 않은 경우는 플로트(float)이고, 정수 값은 형 확장에 따라 영향을 받는다.

<strong>속성(Attribute) : </strong>weightIdentifier [0..1]: identifier

지정된 경우, 정의된 가중치(weight)는 단일 변수를 위한 weightIdentifier의 정의에서 설명된 각각의 변수에 적용된다. 이 속성의 행동은 baseType이 플로트이거나 생략되었을 경우에만 지정된다. 가중치가 지정되었을 때, 표현의 결과는 항상 기본 유형(base-type) 플로트(float)를 갖는다.

<strong>클래스(Class) :</strong> outcomeMaximum (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 이와 동시에 테스트에 참조된 문항의 하위 세트 내 결과 변수의 normalMaximum 값을 찾는다. 단일 다중성(single cardinality)을 갖는 변수 만이 고려대상이 된다. 만약 주어진 하위 세트 내에서 문항 중 그 어떤 것이라도 선언된 maximum을 갖지 않는다면, 결과는 NULL이며, 그렇지 않은 경우 결과는 다중 중복성(cardinality multiple)과 기본 유형(base-type) 플로트(float)를 갖는다.

<strong>속성(Attribute) : </strong>outcomeIdentifier [1]: identifier

testVariables의 variableIdentifier 속성을 따른다.

<strong>속성(Attribute) : </strong>weightIdentifier [0..1]: identifier

testVariables의 weightIdentifier 속성을 따른다.

<strong>클래스(Class) :</strong> outcomeMinimum (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 이와 동시에 테스트에 참조된 문항의 하위 세트 내 결과 변수의 normalMinimum 값을 찾는다. 단일 다중성(single cardinality)을 갖는 변수 만이 고려대상이 되며, 선언된 minimum을 갖지 않는 문항은 무시된다. 결과는 다중 중복성(cardinality multiple)과 기본 유형 플로트(base-type float)를 갖는다.

<strong>속성(Attribute) : </strong>outcomeIdentifier [1]: identifier

testVariables의 variableIdentifier 속성을 따른다.

<strong>속성(Attribute) : </strong>weightIdentifier [0..1]: identifier

testVariables의 weightIdentifier 속성을 따른다.

<strong>클래스(Class) :</strong> numberCorrect (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 주어진 하위 세트의 문항 갯수를 계산하며, 이 문항의 경우 모든 지정된 응답 변수(response variable)들이 그들의 연결 correctResponse와 부합한다. 모든 선언된 응답 변수(response variable)가 correctResponses를 지정한 문항만이 고려대상이 된다. 결과는 단일 다중성(single cardinality)을 갖는 정수(integer)이다.

<strong>클래스(Class) :</strong> numberIncorrect (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 주어진 하위 세트의 문항 갯수를 계산하며, 이 문항의 경우 지정된 응답 변수(response variable) 중 적어도 하나는 그것의 연결 correctResponse와 부합하지 않는다. 모든 지정된 응답 변수(response variable)가 correctResponses를 지정하고 적어도 한번은 시도되었던 문항만이 고려대상이 된다. 결과는 단일 다중성(single cardinality)을 갖는 정수(integer)이다.

<strong>클래스(Class) :</strong> numberResponded (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 시도된 적 있고(적어도 한번) 응답이 제출된 적 있는 주어진 하위 세트의 문항 갯수를 계산한다. 다른 말로 하면, 적어도 하나의 선언된 응답이 선언된 기본값(보통 NULL )과 다른 값을 갖는 문항을 뜻한다. 결과는 단일 다중성(single cardinality)을 갖는 정수(integer)이다.

<strong>클래스(Class) :</strong> numberPresented (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 시도된 적 있는(적어도 한번), 주어진 하위 세트의 문항 갯수를 계산한다. 다른 말로 하면, 응답여부에 상관없이 사용자가 상호작용을 한 문항을 뜻한다. 결과는 단일 다중성(single cardinality)을 갖는 정수(integer)이다.

<strong>클래스(Class) :</strong> numberSelected (expression, itemSubset)

이 표현은, 결과 처리에만 사용될 수 있는데, 시도 여부에 상관없이 응시자에게 제시되기 위해 선택되었던, 주어진 하위 세트의 문항 갯수를 계산한다. 결과는 단일 다중성(<a href="#element10049">single</a> cardinality)을 갖는 정수(integer)이다.

</div>
<div id="sec_15.3" class="section">
<h3><a name="15.3">15.3 오퍼레이터(Operators)</a></h3>
operator는, 단일 하위 표현식을 수정하여 또는 두 개 또는 그 이상의 하위 표현식들을 지정된 방식으로 조합하여 자기 값(결과로 불림)을 도출하는 표현(expression)에서 파생한 클래스 패밀리이다. operator는 itemVariables 값에 직접적으로 영향을 절대로 미치지 않으며, 다시 말해 ‘부작용(side effects)’이 없다.

모든 operator는 baseType과 다중성(cardinality)을 갖는데, 다만 이들은 자신들이 포함하고 있는 하위 표현식에 의존할 수도 있다.

<strong>클래스(Class) :</strong> multiple (expression)

<strong>포함(Contains) :</strong> expression [*]

다중(multiple) operator는 0 또는 그 이상의 하위 표현식을 갖는데, 이들은 모두 단일(single) 또는 다중 중복성(multiple cardinality)을 가져야 한다. 비록 하위 표현식들이 어떠한 기본 유형(base-type) 일 수도 있으나, 이들은 반드시 동일한 기본 유형(base-type)이라야 한다. 결과는 하위 표현식값을 포함하는 다중 중복성(multiple cardinality)을 갖는 컨테이너로, 다중 중복성을 갖는 하위 표현식은 자신의 개별 값을 결과에 추가시킨다: 컨테이너들은 다른 컨테이너들을 포함할 수 없다. 예를 들어 A, B,{C,D}에 적용될 때, 다중 operator는 {A,B,C,D}라는 결과를 거둔다. NULL값을 갖는 모든 하위 표현식은 무시된다. 하위 표현식이 주어지지 않았다면(또는 모두 NULL이면), 결과는 NULL이다.

<strong>클래스(Class) :</strong> ordered (expression)

<strong>포함(Contains) :</strong> expression [*]

순차적(ordered) operator는 0 또는 그 이상의 하위 표현식을 갖는데, 이들은 모두 단일(single) 또는 순차적 다중성(ordered cardinality)을 가져야 한다. 비록 하위 표현식들이 어떠한 기본 유형(base-type) 일 수도 있으나, 이들은 반드시 동일한 기본 유형(base-type)이라야 한다. 결과는 하위 표현식값을 포함하는 순차적 다중성을 갖는 컨테이너로, 순차적 다중성을 갖는 하위 표현식은 자신의 개별 값을 결과에 추가(순서대로)시킨다: 컨테이너들은 다른 컨테이너들을 포함할 수 없다. 예를 들어 A, B,{C,D}에 적용될 때, 순차적 operator는 {A,B,C,D}라는 결과를 거둔다. 순차적 operator는 빈 컨테이너를 갖지 않음을 명심한다. NULL값을 갖는 모든 하위 표현식은 무시된다. 하위 표현식이 주어지지 않았다면(또는 모두 NULL이면), 결과는 NULL이다.

<strong>클래스(Class) :</strong> containerSize (expression)

<strong>포함(Contains) :</strong> expression [1]

containerSize operator는 어떤 하나의 기본 유형(base-type)과 다중(multiple) 또는 순차적 다중성(ordered cardinality) 중의 하나를 갖는 하위 표현식을 취한다. 결과는 하위 표현식에 값 갯수를 부여하는 정수(integer), 다시 말해 컨테이너의 사이즈이다. 만약 하위 표현식이 NULL이면 결과는 0이다. 이 operator는 예를 들어, 다중-응답 choiceInteraction 에서 선택할 수 있는 갯수를 결정하는데 사용될 수 있다.

<strong>클래스(Class) :</strong> isNull (expression)

<strong>포함(Contains) :</strong> expression [1]

isNull operator는 어떤 하나의 기본 유형(base-type)과 다중성(cardinality)을 갖는 하위 표현식을 취한다. 하위 표현식이 NULL이거나 그렇지 않으면 불허(false)인 경우, 결과는 참(true) 값을 갖는 단일 논리(boolean)이다. 빈 컨테이너와 빈 문자열은 모두 NULL로 취급된다는 점을 명심한다.

<strong>클래스(Class) :</strong> index (expression)

<strong>속성(Attribute) : </strong>n [1]: integer

<strong>포함(Contains) :</strong> expression [1]

index operator는 어떤 하나의 기본 유형(base-type)과 순차적(ordered) 컨테이너 값을 갖는 하위 표현식을 취한다. 결과는 컨테이너의 n번째(nth) 값이다. 결과는 하위 표현식과 동일한 기본 유형(base-type)를 가져야 하지만 단일 다중성(single cardinality)라야 한다. 컨테이너의 첫 번째 값이 색인 1을 갖고, 두 번째 값은 2를 갖는 식으로 된다. n 은 반드시 양의 정수(integer)라야 한다. n이 컨테이너 안 값의 갯수를 초과하면, 색인 operator의 결과는 NULL이다.

<strong>클래스(Class) :</strong> fieldValue (expression)

<strong>속성(Attribute) : </strong>fieldIdentifier [1]: identifier

선택대상 필드의 식별자

<strong>포함(Contains) :</strong> expression [1]

field-value operator는 레코드(record) 컨테이너 값을 갖는 하위 표현식을 취한다. 결과는 지정된 fieldIdentifier를 갖는 필드값이다. 이 식별자를 갖는 필드가 없다면, operator의 결과는 NULL이다.

<strong>클래스(Class) :</strong> random (expression)

<strong>포함(Contains) :</strong> expression [1]

random operator는 다중(multiple) 또는 순차적(ordered) 컨테이너 값과 어떠한 기본 유형(base-type)을 갖는 하위 표현식을 취한다. 결과는 컨테이너에서 무작위로(randomly) 선택한 단일 값이다. 이 결과는 하위 표현식과 동일한 기본 유형(base-type)을 갖지만 단일 다중성(single cardinality)를 갖는다. 만약 하위 표현식이 NULL 이면 결과 또한 NULL이다.

<strong>클래스(Class) :</strong> member (expression)

<strong>포함(Contains) :</strong> expression [2]

member operator는 동일한 기본 유형(base-type)을 갖는 두 개의 하위 표현식을 취한다. 첫 번째 하위 표현식은 반드시 단일 다중성(single cardinality)을 가져야 하며 두 번째는 다중(multiple) 또는 순차적(ordered) 컨테이너라야 한다. 만약 첫 번째 하위 표현식이 부여한 값이 두 번째 하위 표현식이 지정한 컨테이너 안에 있다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이다. 만약 둘 중 어느 하나가 NULL이면, operator 결과는 NULL이다.

멤버 operator는 값들 간의 비교가 불충분하게 정의되기 때문에 플로트(float) 기본 유형(base-type)를 갖는 하위 표현식에 사용될 수 없다. 실행시간(duration) 기본 유형(base-type)를 갖는 하위 표현식에 사용되어서는 안된다.

<strong>클래스(Class) :</strong> delete (expression)

<strong>포함(Contains) :</strong> expression [2]

delete operator는 동일한 기본 유형(base-type)을 갖는 두 개의 하위 표현식을 취한다. 첫 번째 하위 표현식은 반드시 단일 다중성(single cardinality)를 가져야 하며 두 번째는 다중(multiple) 또는 순차적(ordered) 컨테이너라야 한다. 결과는 첫 번째 하위 표현식의 모든 인스턴스가 제거된 두 번째 하위 표현식에서 추출된 새 컨테이너다. 예를 들어, A 와 {B,A,C,A}를 적용할 때, 결과는 컨테이너 {B,C}이다. 만약 둘 중 어느 하나가 NULL이면, operator 결과는 NULL이다.

멤버(member) operator에 적용되는 제한은 삭제(delete)operator에도 적용된다.

<strong>클래스(Class) :</strong> contains (expression)

<strong>포함(Contains) :</strong> expression [2]

contains operator는 두 개의 하위 표현식을 취하며, 이 둘은 모두 동일한 기본 유형(base-type)과 cardinality-- 다중(multiple) 또는 순차적(ordered) 중의 하나—을 가져야 한다. 만약 첫 번째 하위 표현식이 부여한 컨테이너가 두 번째 하위 표현식이 부여한 값을 포함한다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 그렇지 않으면 불허(false)이다. 포함 operator는 이 두 하위 표현식의 다중성(cardinality)에 따라 다르게 작동할 수 있음을 명심한다. 비순차적(unordered) 컨테이너의 경우, 그 값들은 배열(ordering)에 관계없이 비교된다. 예를 들어, [A,B,C] 는 [C,A]를 포함하는 것이다. [A,B,C]가 [B,B]을 포함하지는 않지만 [A,B,B,C]는 [B,B]를 포함한다는 점을 명심한다. 순차적(ordered) 컨테이너의 경우, 두 번째 하위 표현식은 첫 번째 하위 표현식식내에서 반드시 하위 시퀀스(sub-sequence)라야 한다. 다시 말해, [A,B,C]는 [C,A]를 포함하지 않지만 [B,C]를 포함한다는 것이다.

둘 중 하나의 하위 표현식이 NULL이면, operator 결과는 NULL이다. 멤버 operator와 마찬가지로, contains operator는 플로트(float) 기본 유형(base-type)을 갖는 하위 표현식에 사용되어서는 안되며 실행시간(duration) 기본 유형(base-type)을 갖는 하위 표현식에 사용될 수 없다.

<strong>클래스(Class) :</strong> substring (expression)

<strong>포함(Contains) :</strong> expression [2]

substring operator는 두 개의 하위 표현식을 취하며, 이 둘은 모두 문자열(string)과 단일 다중성(single cardinality)의 유효한 기본 유형(base-type)을 가져야 한다. 만약 첫 번째 하위 표현식이 두 번째 하위 표현식의 하위 문자열인 경우, 결과는 true 값을 갖는 단일 논리(boolean)이며, 그렇지 않다면 결과는 불허(false)이다. 만약 둘 중 어느 하나가 NULL이면, operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>caseSensitive [1]: boolean = true

하위 문자열(substring)의 대소문자 구별을 통제하기 위해 사용된다. 참(true)이면 대소문자를 구별한다. 예를 들어, "Hell"은 "Shell"의 하위 문자열이 아니다. 불허(false)이면, 대소문자를 구별하지 않으므로, "Hell"이 "Shell"의 하위 문자열이다.

<strong>클래스(Class) :</strong> not (expression)

<strong>포함(Contains)</strong> : expression [1]

not operator는 논리(boolean)와 단일 다중성(single cardinality)의 기본 유형(base-type)을 갖는 단일 하위 표현식을 취한다. 결과는 하위 표현식값의 논리부정으로 도출된 값을 갖는 단일 논리(boolean)이다. 이 하위 표현식이 NULL이면, not operator는 또한 NULL의 결과를 갖는다.

<strong>클래스(Class) :</strong> and (expression)

<strong>포함(Contains) :</strong> expression [1..*]

and operator는 하나 또는 그 이상의 하위 표현식을 취하며, 각각 논리(boolean)와 단일 다중성(single cardinality)의 기본 유형(base-type)을 갖는다. 만약 모든 하위 표현식이 참(true)이면 결과는 참(true) 값을 갖는 단일 논리(boolean) 이고, 어느 하나의 표현식이 false 이면 단일 불리언이 불허(false)이다. 만약 하나 또는 그 이상의 하위 표현식이 NULL이고 모든 다른 표현식이 참(true)이면, operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> or (expression)

<strong>포함(Contains) :</strong> expression [1..*]

or operator는 하나 또는 그 이상의 하위 표현식을 취하며, 각각 논리(boolean)와 단일 다중성(single cardinality)의 기본 유형(base-type)을 갖는다. 결과는, 만약 하위 표현식 중 하나라도 참(true)이면 단일 논리(boolean)는 참(true)이고, 모든 표현식이 불허(false)이면 단일 논리가 불허(false)이다. 만약 하나 또는 그 이상의 하위 표현식이 NULL이고 모든 다른 표현식이 불허(false)이면, operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> anyN (expression)

<strong>포함(Contains) :</strong> expression [1..*]

anyN operator는 하나 또는 그 이상의 하위 표현식을 취하며, 각각 논리(boolean)와 단일 다중성(single cardinality)의 기본 유형(base-type)을 갖는다. 하위 표현식 중 적어도 min이 참(true)이고 많아야 max가 참(true)이면, 단일 논리(boolean)는 참(true)이다. 만약 n – min보다 많은 수의 하위 표현식이 불허(false)이고 (n은 하위 표현식의 총합이라고 할 때) 또는 max 보다 많은 하위 표현식이 참(true) 이면, 결과는 불허(false)이다. 하나 또는 그 이상의 하위 표현식이 NULL이면, 이들 조건 중 그 어느 것도 만족되지 않을 가능성이 있으며, 이 경우 operator 결과는 NULL이다. 예를 들어, min이 3이고 max 가 4이면서, 하위 표현식의 값이 {true, true, false, NULL}이면, operator 결과는 NULL이다. 반면 {true, false, false, NULL} 값의 결과는 불허(false)이며, {true,true,true,NULL}은 참(true)이다. 결과가 NULL이라는 것은 operator의 바른 값(correct value)을 결정할 수 없음을 의미한다.

<strong>속성(Attribute) : </strong>min [1]: integerOrTemplateRef

반드시 true 라야 하는 하위 표현식의 최소치

<strong>속성(Attribute) : </strong>max [1]: integerOrTemplateRef

true 일 수 있는 하위 표현식의 최대치

<strong>클래스(Class) :</strong> match (expression)

<strong>포함(Contains) :</strong> expression [2]

match operator는 두 개의 하위 표현식을 취하며, 이 둘은 반드시 동일한 기본 유형(base-type)과 다중성(cardinality)을 가져야 한다. 결과는, 만약 두 표현식이 같은 값을 나타내면 단일 논리(boolean)는 참(true)이고, 나타내지 못하면 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

match operator는 수량적 평등(numerical equality) 같은 등가성(equality)의 광의적 개념과 혼동되어서는 안된다. 이를 방지하기 위해서 match operator는 하위 표현식을 플로트(float) 기본 유형(base-type)과 비교하는 데 사용되어서는 안되며, 실행시간(duration) 기본 유형(base-type)를 갖는 하위 표현식에 사용되어서는 안 된다.

<strong>클래스(Class) :</strong> stringMatch (expression)

<strong>포함(Contains) :</strong> expression [2]

stringMatch operator는 두 개의 하위 표현식을 취하며, 이 둘은 반드시 단일의 문자열(<a href="#element10058">string</a>) 기본 유형(base-type)을 가져야 한다. 결과는, 만약 두개의 문자열이 아래 속성이 지정한 비교규칙을 토대로 일치(match)하면 단일 논리(boolean)는 참(true)이고, 일치(match)하지 않으면 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>caseSensitive [1]: boolean

매치(match)가 대소문자 구별로 실행될 것인가의 여부

<strong>속성(Attribute) : </strong>substring [0..1]: boolean = false

이 속성은 현재 권장되지 않으며(deprecated), substring operator가 대신 사용되어야 한다. 참(true)이면 첫 번째 문자열이 두 번째 문자열을 포함하는 경우 비교(comparison) 연산자가 "true"를 반환하는데, 그렇지 않으면 문자열이 전부 일치해야 "ture"를 반환한다.

<strong>클래스(Class) :</strong> patternMatch (expression)

<strong>포함(Contains) :</strong> expression [1]

patternMatch operator는 하나의 하위 표현식을 취하는데, 이는 반드시 단일 중복성(single cardinality)과 문자열(string) 기본 유형(base-type)을 가져야 한다. 결과는, 만약 하위 표현식이 패턴(pattern)이 제시한 정규 표현식(regular expression)에 부합하면, 단일 논리(boolean)는 참(true)이며, 부합하지 않는다면 불허(false)이다. 만약 하위 표현식이 NULL이면, operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>pattern [1]: stringOrTemplateRef

정규 표현식(regular expression) 언어의 신텍스는 [XML_SCHEMA2]의 첨부F에 지정된 것과 같다.

<strong>클래스(Class) :</strong> equal (expression)

<strong>포함(Contains) :</strong> expression [2]

equaloperator는 두 개의 하위 표현식을 취하며 둘 다 반드시 단일 중복성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 두 표현식이 수치적으로 동등한 경우 결과는 true 값을 갖는 단일 불리언(boolean)이며, 동등하지 않은 경우, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>toleranceMode [1]: toleranceMode = exact

두 개의 부동 소수점(floating point) 숫자를 등가 비교할 때, 채점에서 반올림 오류(rounding error)로 인해 거짓 오류(spurious error)가 발생하지 않도록 공차(tolerance)를 두는 것이 종종 바람직할 수 있다. 이러한 공차모드(tolerance mode)는 비교 연산이 정확하게 실행되는 가를 절대적 범위(absolute range) 또는 상대적 범위(relative range)를 사용하여 판단한다.

<strong>속성(Attribute) : </strong>tolerance [0..2]: floatOrTemplateRef

공차 모드가 절대적(absolute) 또는 상대적(relative)이면, 이 공차(tolerance)는 반드시 구체적으로 명시되어야 한다. 공차는 두 개의 양의 수, t0 과 t1로 구성되며, 이는 하한(lower bound)와 상한(upper bound)를 정의한다. 값이 하나만 주어졌다면, 둘 다를 위해 쓰인다.

절대적 모드(absolute mode)에서, 두 번째 표현식, y가, 첫 번째 값 x 가 정의한 다음 범위 내에 있다면, 비교연산의 결과는 참(true)이다.

x-t0,x+t1

상대적 모드(relative mode)에서, t0 과 t1는 퍼센티지로 취급되며, 다음 범위가 대신 사용된다.

x*(1-t0/100),x*(1+t1/100)

<strong>속성(Attribute) : </strong>includeLowerBound [0..1]: boolean = true

하한(lower bound)이 비교연산에 포함될 것인가의 여부를 통제한다.

<strong>속성(Attribute) : </strong>includeUpperBound [0..1]: boolean = true

상한(upper bound)이 비교연산에 포함될 것인가의 여부를 통제한다.

열거(Enumeration) : toleranceMode

exact

absolute

relative

<strong>클래스(Class) :</strong> equalRounded (expression)

<strong>포함(Contains) :</strong> expression [2]

equalRounded operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 중복성(single cardinality)과 숫자형 기본 유형(numerical base-type) 을 갖는다. 두 표현식이 반올림 이후에 수치적으로 동등한 경우, 결과는 true 값을 갖는 단일 논리(boolean)이며, 동등하지 않은 경우, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>roundingMode [1]: roundingMode = significantFigures

숫자들은 significantFigures 또는 decimalPlaces의 주어진 수로 반올림된다.

<strong>속성(Attribute) : </strong>figures [1]: integerOrTemplateRef

반올림할 숫자의 갯수

예를 들어, 두 값이 1.56 과 1.6이고, significantFigures가 figures=2 와 함께 사용되면, 결과는 참(true)이 된다.

열거(Enumeration) : roundingMode

significantFigures

decimalPlaces

<strong>클래스(Class) :</strong> inside (expression)

<strong>포함(Contains) :</strong> expression [1]

inside operator는 포인트(point)의 baseType을 가져야 하는 단일 하위 표현식을 취한다. 결과는, 주어진 포인트가 shape와 coords가 지정한 영역 내에 있다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이다. 만약 하위 표현식이 컨테이너라면, 결과는 참(true)이고, 어떤 포인트 라도 영역 안에 있다면, 결과는 참(true)이다. 어느 한 쪽의 하위 표현식이 NULL이면, operator 결과는 NULL이다.

<strong>속성(Attribute) : </strong>shape [1]: shape

영역의 shape

<strong>속성(Attribute) : </strong>coords [1]: coords

영역의 사이즈와 포지션으로 shape와 함께 해석된다.

<strong>클래스(Class) :</strong> lt (expression)

<strong>포함(Contains) :</strong> expression [2]

It operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 중복성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 첫 번째 표현식이 수치적으로 두 번째 표현식보다 작다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 크거나 동일하다면, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> gt (expression)

<strong>포함(Contains) :</strong> expression [2]

gt operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 다중성(single cardinality)와 숫자형 기본 유형(numerical base-type)을 갖는다. 첫 번째 표현식이 수치적으로 두 번째 표현식보다 크다면, 결과는 true 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 작거나 동일하다면, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> lte (expression)

<strong>포함(Contains) :</strong> expression [2]

lte operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 다중성(single cardinality)와 숫자형 기본 유형(numerical base-type)을 갖는다. 첫 번째 표현식이 수치적으로 두 번째 표현식보다 작거나 동일하다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 크다면, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> gte (expression)

<strong>포함(Contains) :</strong> expression [2]

gte operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 다중성(single cardinality)와 숫자형 기본 유형(numerical base-type)을 갖는다. 첫 번째 표현식이 수치적으로 두 번째 표현식보다 작거나 동일하다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 크다면, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> durationLT (expression)

<strong>포함(Contains) :</strong> expression [2]

durationLT operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 다중성(single cardinality)와 기본 유형(base-type) 실행시간(duration)을 갖는다. 첫 번째 실행시간이 두 번째 실행시간보다 짧다면, 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 길다면(또는 동일하면), 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

'durationLTE' 이나 'durationGT' 은 존재하지 않는다. 이는 실행시간이 허용하는 변수의 정확성을 감안할 때 실행시간의 동등성(equality)은 무의미하기 때문이다. 실행시간 값이 반올림(rounding)하기 보다는 잘라내기(truncation)에 의해 도출된다는 점을 고려할 때, 보다 작은 것만 또는 크거나 같은 부등식(inequality) 만을 테스트 하는 것이 합리적이다. 예를 들어, 만약 엡실론(epsilon) 초(epsilon&lt;1)의 resolution에 실행시간을 보고하는 시스템에서 한 응시자가 과제를 10초 내에 마칠 수 있는 가를 결정하고자 할 때, 10과 동일한 값은 그 범위[10,10+epsilon) 안에 있는 모든 실행시간을 다룰 것이다.

<strong>클래스(Class) :</strong> durationGTE (expression)

<strong>포함(Contains) :</strong> expression [2]

durationGTE operator는 두 개의 하위 표현식을 취하며, 이들은 반드시 단일 다중성(single cardinality)와 기본 유형(base-type) 실행시간(duration)을 갖는다. 첫 번째 실행시간이 두 번째 실행시간보다 길다면(또는 동일하다면, 위에서 설명한 잘라내기(truncation)이 부여한 제한 내에서), 결과는 참(true) 값을 갖는 단일 논리(boolean)이며, 두 번째 표현식보다 짧다면, 불허(false)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

실행시간의 동등성(equality) 평가에 대한 추가 정보는 durationLT 참조

<strong>클래스(Class) :</strong> sum (expression)

<strong>포함(Contains) :</strong> expression [1..*]

sum operator는 하나 또는 그 이상의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 결과는 단일 플로트(float)이거나, 만약 모든 하위 표현식이 정수(integer) 유형이면, 결과는 하위 표현식들의 숫자값의 합(sum)에 해당하는 단일 정수이다. 표현식 중 어느 하나라도 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> product (expression)

<strong>포함(Contains) :</strong> expression [1..*]

product operator는 하나 또는 그 이상의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 결과는 단일 플로트(float)이거나, 만약 모든 하위 표현식이 정수(integer) 유형이면, 결과는 하위 표현식들의 숫자값의 product에 해당하는 단일 정수이다. 표현식 중 어느 하나라도 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> subtract (expression)

<strong>포함(Contains) :</strong> expression [2]

subtract operator는 두 개의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 결과는 단일 플로트(float)이거나, 만약 두 하위 표현식이 모두 정수(integer) 유형이면, 결과는 첫 번째 값에서 두 번째 값을 뺀 것에 해당하는 단일 정수이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> divide (expression)

<strong>포함(Contains) :</strong> expression [2]

divide operator는 두 개의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 결과는 첫 번째 표현식을 두 번째 표현식으로 나눈 것에 해당하는 단일 플로트(float)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

문항 저작자는 두 번째 표현식 값이 절대로 0이 되니 않도록 모든 노력을 기울여야 하며, 만약 0이 나오거나 결과 값이 플로트(float)(양의 또는 음의 무한대를 포함하지 않는)가 지정한 값 세트를 벗어난다면, operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> power (expression)

<strong>포함(Contains) :</strong> expression [2]

power operator는 두 개의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 숫자형 기본 유형(numerical base-type)을 갖는다. 결과는 두 번째 표현식의 파워까지 올라간 첫 번째 표현식에 해당하는 단일 플로트(float)이다. 두 표현식 중 하나가 NULL이면 operator 결과는 NULL이다.

만일 결과값이 플로트(float)(양과 음의 무한대를 포함하지 않는)가 지정한 값 세트 밖에 있다면, operator 결과는 NULL이다.

<strong>클래스(Class) :</strong> integerDivide (expression)

<strong>포함(Contains) :</strong> expression [2]

integer divide operator는 두 개의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 기본 유형(base-type) 정수(integer) 갖는다. 결과는 첫 번째 표현식(x)를 두 번째 표현식(y)로 나누고 최대정수(i)까지 반내림한 것에 해당하는 단일 정수이며, 그 식은 i&lt;=(x/y)로 표현된다. 만약 y가 0이면, 또는 하위 표현식 중의 하나가 NULL이면 operator 결과는 NULL 이다.

<strong>클래스(Class) :</strong> integerModulus (expression)

<strong>포함(Contains) :</strong> expression [2]

integer modulus 오퍼레이트는 두 개의 하위 표현식을 취하며, 이들은 모두 단일 다중성(single cardinality)과 기본 유형(base-type) 정수(integer) 갖는다. 결과는 첫 번째 표현식(x)이 두 번째 표현식(y)으로 나뉘고 남은 나머지에 해당하는 단일 정수이다. 만약 z가 해당 integerDivide operator의 결과이면, 그 결과는 x-z*y 로 표현된다. 만약 y가 0이면, 또는 하위 표현식 중의 하나가 NULL이면 operator 결과는 NULL 이다.

<strong>클래스(Class) :</strong> truncate (expression)

<strong>포함(Contains) :</strong> expression [1]

truncate operator는 단일 하위 표현식을 취하며, 이는 반드시 단일 다중성(single cardinality)과 기본 유형(base-type) 플로트(float)를 갖는다. 결과는 0에 가까운 하위 표현식 값을 잘라냄으로 만들어진 기본 유형(base-type) 정수(integer) 값이다. 예를 들어, 값 6.8은 6이 되며, 값 -6.8은 -6이 되는 것이다. 하위 표현식이 NULL이면 operator 결과는 NULL 이다.

<strong>클래스(Class) :</strong> round (expression)

<strong>포함(Contains) :</strong> expression [1]

round operator는 단일 하위 표현식을 취하여 이는 반드시 단일 다중성(single cardinality)과 기본 유형(base-type) 플로트(float)를 갖는다. 결과는 0에 가까운 하위 표현식 값을 반올림해서 만들어진 기본 유형(base-type) 정수(integer) 값이다. 결과는 [n-0.5,n+0.5) 범위 에서 모든 인풋 값에 대한 정수 n인 것이다. 다른 말로, 6.8 과 6.5 은 둘 다 7로 반올림 되고, 6.49 는 6으로 반내림되며, -6.5는 -6 반올림 되는 것이다. 하위 표현식이 NULL이면 operator 결과는 NULL 이다.

<strong>클래스(Class) :</strong> integerToFloat (expression)

<strong>포함(Contains) :</strong> expression [1]

integerToFloat operator는 단일 하위 표현식을 취하며, 이는 반드시 단일 다중성(single cardinality)과 기본 유형(base-type) 정수(integer)를 갖는다. 결과는 동일한 숫자 값을 갖는 기본형 기본 유형 플로트(base-type float)이다. 하위 표현식이 NULL이면 operator 결과는 NULL 이다.

<strong>클래스(Class) :</strong> customOperator (expression)

Custom operator는 이 표준에서는 현재 지원되지 않는 오퍼레이션을 정의하기 위한 확장 매커니즘을 제공한다.

<strong>속성(Attribute) : </strong>class [0..1]: identifier

클래스 속성은 단순 하위 클래스에게 이름을 붙여준다. 하위 클래스의 정의는 tool specific이며 toolName과 toolVersion에서 추론될 수 있다.

<strong>속성(Attribute) : </strong>definition [0..1]: uri

전역 네임스페이스(global namespace)에서 custom operator의 정의를 식별하는 URI.

클래스(class) 및 정의(definition) 속성에 더하여, 하위 클래스들은 자체 속성의 어떤 수라도 첨가할 수 있다.

<strong>포함(Contains) :</strong> expression [*]

Custom operator는 파라미터로 취급될 어떠한 유형의 하위 표현식이 갖는 어떤 수라도 취할 수 있다.

customOperator가 이 표준이 정의한 처리 규칙을 웹서비스 기반 처리 엔진의 인스턴스로 링크시키는 데 사용될 수 있도록 제안되었다. 예를 들어, 자유 기술(free text) 응답의 자동 마킹을 제공했던 웹서비스가 그것이다. 이러한 접근법을 실험하는 실행자(Implementors)들은 그들의 솔루션 정보를 공유하여 이러한 유형의 처리를 달성하기 위한 가장 좋은 방법의 결정을 도울 수 있도록 권장된다.

</div>
</div>
<!-- chap 15 -->
<div id="chap_16" class="chapter">
<h2><a name="16">16 문항 및 테스트 구성요소(Item and Test Fragments)</a></h2>
Item Fragment는 그것에 의존하는 문항들 중에서 독립적으로 다루어 지는 문항의 일부이다. 마찬가지로, Test Fragment는 그것에 의존하는 테스트들 중에서 독립적으로 다루어 지는 테스트의 일부이다. 구성요소(fragments)들은 개별 리소스로 묶여지며, 독립적으로 이동될 수 있다. 하나의 구성요소는 다음 추상 클래중의 하나에서 전해진 모든 클래스의 인스턴스로서 정의된다: flow, responseRule, sectionPart 또는 outcomeRule. 예를 들어, 하나의 문항 구성요소는 div 클래스의 인스턴스가 나타내는 itemBody의 디비전(division)일 수 있다.

<strong>클래스(Class) :</strong> include (flow, outcomeRule, responseRule, sectionPart)

구성요소들은 Xinclude 매커니즘을 사용하여 포함된다. ([XINCLUDE] 참조) include 인스턴스는, 마치 인클루드(include) 요소의 href 속성에 의해 참조된 구성요소의 최상위(root)요소의 실제 인스턴스인 것처럼 취급된다. 이 표준의 목적을 위해, XInclude 표준이 정의한 xpointer 매커니즘은 사용되어서는 안된다. 또한 모든 포함된 구성요소들은 parsed xml로 취급되어야 한다.

이 기술은 미디어 객체(object를 사용하여)의 포함(inclusion)과 유사하지만, 이 표준을 따르는 데이터의 포함을 허용한다. 특히, 이 기술은 상호작용(interactions), 정적 콘텐츠(static content), 처리 규칙, 또는 테스트 레벨에서의 전체 섹션이 외부에서 정의된 구성요소에서 포함되도록 허용한다.

외부에서 정의된 구성요소를 포함할 때, 구성요소 콘텐츠는 포함되고 있는 문항의 문맥(context) 표준의 요건을 반드시 만족시켜야 한다. 예를 들어, 구성요소로부터 포함된 상호작용은 반드시 그 분항에서 선언된 응답 변수(response variable)에 올바르게 바인딩되어야 한다.

<strong>클래스(Class) :</strong> responseProcessingFragment (responseRule)

<strong>포함(Contains) :</strong> responseRule [*]

responseProcessingFragment은 responseRules의 단순한 그룹으로, 이들을 개별 리소스로 다루어 지도록 하기 위한 목적으로 집단화 된 것이다. 이 클래스는 다른 어떠한 목적으로도 사용될 수 없다.

응답 처리 템플릿은 시스템이 개별 응답 처리 규칙을 분석할 필요 없이 응답 처리를 실행하도록 허용한다는 것을 명심한다. 반면 하나의 외부에서 정의된 응답 처리 구성요소에 대한 참조를 포함하는 responseProcessing 요소는 행동 실행을 결정하기 위해 반드시 분석되어야 한다.

<strong>클래스(Class) :</strong> outcomeProcessingFragment (outcomeRule)

<strong>포함(Contains) :</strong> outcomeRule [*]

outcomeProcessingFragment 는 outcomeRules 의 단순한 그룹으로, 이들을 개별 리소스로 다루어 지도록 하기 위한 목적으로 집단화 된 것이다. 이 클래스는 다른 어떠한 목적으로도 사용될 수 없다.

</div>
<!-- chap 16 -->
<div id="chap_17" class="chapter">
<h2><a name="17">17 기본 데이터 유형(Basic Data Types)</a></h2>
<strong>데이터유형(Datatype)</strong>: boolean

boolean 값은 참(true) 이거나 불허(false)이다. "Yes", "TRUE", "1", etc. 같은 문자열에 대한 어휘적 바인딩(lexical bindings)은 이 문서의 범위를 벗어나는 것이다.

<strong>데이터유형(Datatype)</strong>: coords

Cords 유형은 해당 shape가 정의하는 영역의 크기와 위치를 결정하는 좌표를 제공한다.

좌표 자체는 길이의 순차적 목록([XHTML]에 정의된 대로)이다. 각각의 길이 값 해석은 다음과 같은 연결 shape 값에 의존한다.
<ul>
	<li>rect: 좌-x, 위-y, 우-x, 아래-y.</li>
	<li>circle: 중앙-x, 중앙-y, 반지름. 유의사항. 반지름이 퍼센티지 값일 때, 사용자 에이전트는 연관 객체의 폭과 높이를 기초로 최종 반지름 값을 계산해야 한다. 반지름은 둘 중에서 작은 값이다.</li>
	<li>poly: x1, y1, x2, y2, ..., xN, yN. 첫 번째 x 와 y 좌표 페어 그리고 마지막 것은 폴리곤(polygon)을 닫기 위해 동일한 것이라야 한다. 이들 좌표 값이 동일하지 않을 때, 사용자 에이전트는 폴리곤을 닫기 위해 추가 좌표 쌍(Pair)를 추론해야 한다.</li>
	<li>ellipse: 중앙 -x, 중앙-y, h-반지름, v-반지름. 타원형은 [XHTML]에 의해 정의되지 않기 때문에 권장되지 않는다는(deprecated) 점에 유의한다.</li>
	<li>default: 좌표가 주어지지 않는다</li>
</ul>
<strong>데이터유형(Datatype)</strong>: date

완전하게 지정된 달력 날짜로, [ISO8601]에 정의된 참조 시스템부터의 연도, 월, 일이 포함된다. 유효한 연도의 범위는 0001-9999이다. 연도값은 시간대 정보를 갖지 않는다.

<strong>데이터유형(Datatype)</strong>: datetime

[ISO8601]에서 정의된 참조 시스템에서 완전하게 지정된 달력 날짜와 시간. 유효한 연도의 범위는 0000-9999이다.

<strong>데이터유형(Datatype)</strong>: duration

초 단위로 측정되는 시간의 기간

<strong>데이터유형(Datatype)</strong>: float

IEEE 2배 정밀도 64 비트의 부동 소수점(floating point) 유형

<strong>데이터유형(Datatype)</strong>: identifier

identifier는 예를 들어 itemVariable 또는 choice와 같은, 문항의 다른 객체에 대한 단순한 논리적 참조이다. 하나의 식별자는 반드시 알파벳 글자 하나 또는 밑줄('_')로 시작하며, 글자, 밑줄, 하이픈('-'), 마침표('.', 다른 말로 full-stop), 숫자, CombiningChars, 확장기(extenders)로만 이루어 진다. 마침표를 포함하는 식별자는 나중에 사용될 것을 대비해 확보해 둔다. 문자 클래스인 글자, 숫자, CombiningChars, 확장기(extenders)는 Extensible Markup Language (XML) 1.0 (Second Edition) [XML]에서 정의되어 있다. 특히 유념할 사항은 식별자는 콜론(':') 문자를 포함하지 않을 수도 있다는 점이다. 식별자는 버전 1과의 호환성 때문에 32글자를 초과할 수 없다. 이들은 항상 대소문자 구별(case-sensitively)하여 비교된다.

<strong>데이터유형(Datatype)</strong>: integer

정수(integer)값은 [-2147483648,2147483647] 범위의 전체 숫자라고 할 수 있다. 이는 2의 보수(twos-complement) 32 비트 정수이다.

<strong>데이터유형(Datatype)</strong>: language

[RFC3066]가 정의하는 대로의 자연어 식별자

<strong>데이터유형(Datatype)</strong>: length

[XHTML]에서 정의된 대로의 길이 datatype

<strong>데이터유형(Datatype)</strong>: mimeType

[RFC2045]가 정의한 대로의 mime 유형들(유형과 하위유형) 세트

열거(Enumeration) : orientation

vertical

horizontal

열거(Enumeration) : shape

shape 값은 항상 좌표를 동반한다 (coords 및 이를 해석하기 위한 콘텍스트를 제공하는 연관 이미지를 참조).

default

기본 shape는 연관 이미지의 전체 영역을 참조한다.

rect

직사각형 지역

circle

원형 지역

poly

임의의 다각형 지역

ellipse

이 값은 권장되지 않지만 QTI 표준의 버전1과의 호환성을 위해 포함된다. 시스템은 대신 circle 또는 poly shape를 사용해야 한다.

<strong>데이터유형(Datatype)</strong>: string

string 값은 문자의 모든 시퀀스이다. 문자는 Extensible Markup Language (XML) 1.0 (Second Edition)에저 정의된 Char 클래스 안의 어떤 것이든 된다.

<strong>데이터유형(Datatype)</strong>: string256

길이가 256 글자 수로 제한되어 있는 문자열 값 (string에 따라서)

<strong>데이터유형(Datatype)</strong>: styleclass

예를 들어 스타일시트에서와 같이 클래스 정의를 참조할 때 사용되는 유형이다. 클래스 이름에 공간이 있을 수 없다.

<strong>데이터유형(Datatype)</strong>: uri

[URI]에 정의된 대로의 URL(Uniform Resource Identifier)

<strong>데이터유형(Datatype)</strong>: valueType

평가 변수 데이터 모델에서 정의된 대로 모든 baseType의 단일 값을 표현하기 위해 사용되는 단순 유형이다.

열거(Enumeration) : view

author

candidate

proctor

때때로 감독관(invigilator)으로 불리기도 한다.

scorer

testConstructor

tutor

</div>
<!-- chap 17 -->

</div>
<!-- book -->
